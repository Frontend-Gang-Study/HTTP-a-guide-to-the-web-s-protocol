# 15장 엔터티와 인코딩
    
-   http는 매일 수십억 개의 미디어 객체(텍스트, 이미지, 동영상, 소프트웨어 프로그램 등)를 실어 나른다.
    
-   http가 보장하는 것
    
    -   객체는 올바르게 식별되므로(content-type 미디어 포맷과 content-language 헤더를 이용해서) → 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
    -   객체는 올바르게 압축이 풀릴 것이다(content-length와 content-encoding 헤더를 이용해서)
    -   객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용해서)
    -   사용자의 요구를 만족할 것이다(내용 협상을 위한 accept 관련 헤더들에 기반해서)
    -   네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩 등의 데이터 압축을 이용해서)
    -   조작되지 않고 온전하게 도착할 것이다.(전송 인코딩 헤더와 content-md5 체크섬을 이용해서)
    
    ----------
    
    -   이를 가능하게 하기 위해 → http는 잘 라벨링된 엔터티를 사용한다.

##   15.1 메시지는 컨테이너, 엔터티는 화물

    
-   엔터티는 http 데이터를 담는다.
    
-   메시지 엔터티는 엔터티 헤더와 엔터티 본문으로 이뤄진다.
    
    _아 여태껏 책에서 말한 엔터티가 본문 아니였음? 흠.._
    _엔터티에 엔터티 헤더가 포함되네_

-   HTTP 엔터티 헤더
    
    -   HTTP 메시지 헤더의 하위 개념이다.
    -   http 메시지의 내용물을 설명한다.
-   엔터티 본문
    
    -   엔터티 본문은 가공되지 않은 데이터만 담는다.(다른 정보는 모두 헤더에 담겨있다) 때문에 엔터티 헤더는 그 데이터의 의미에 대해 설명해준다.
        
    -   CRLF 줄 바로 다음부터 시작한다.



##   15.2 content-length : 엔터티의 길이
    
-   어떻게 http가 엔터티 본문의 크기를
    
    -   작성하는지
    -   측정하기 위해 무엇을 요구하는지
-   엔터티 헤더
    
    -   는 콘텐츠의 포맷, 문자, 언어를 작성하기 위해 사용된다.
    -   는 클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공된다.
-   content-length
    
    -   메시지의 엔터티 본문의 크기를 나타낸다
        -   바이트 단위
        -   어떻게 인코딩 됐든 상관없이 크기를 표현할 수 있다
    -   엔터티 본문을 포함한 메시지에선 필수로 있어야 한다.
        -   예외 : 메시지를 청크 인코딩으로 전송하는 경우
    -   메시지가 잘렸는지 감지할때 필요하다.


###   15.2.1 잘림 검출

-   예전 버전의 http는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다. 하지만 content-length가 없으면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 비정상적으로 닫힌 것인지 구분하지 못한다.
    
-   메시지 잘림은 캐싱 프락시에서 특히 취약하다.
    
    만약 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못했다면, 캐시는 결함이 있는 콘텐츠를 저장하고, 계속해서 제공할 것이다.
    
    잘린 메시지를 캐시하는 위험을 줄이기 위해 → 캐싱 프락시는 명시적으로 content-length 헤더를 가지지 않는 http 본문은 보통 캐시하지 않는다.
    
###   15.2.2 잘못된 content-length

-   content-length가 잘못된 값을 담으면, 생략된 것보다도 큰 피해를 유발할 수 있다.
-   공식적으로 http/1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 → 사용자에게 알려주기 돼 있다.

###   15.2.4 콘텐츠 인코딩

-   본문의 콘텐츠가 인코딩돼 있다면 → content-length 헤더는 인코딩 되지 않은 원본의 길이가 아닌, 인코딩된 본문의 길이를 바이트 단위로 정의한다.
-   어떤 http 애플리케이션은 잘못해서 인코딩 전의 크기를 보내는데, 이는 특히 지속 커넥션일 때 심각한 오류를 유발한다. 불행히도 http/1.1 명세에 작성된 어떤 헤더도 인코딩 되지 않은 원 본문의 길이를 보내기 위해 사용될 수 없는데, 이는 클라가 자신이 한 디코딩 과정에 문제가 없었는지 검증하기 어렵게 만든다.

###   15.2.5 엔터티 본문 길이 판별을 위한 규칙

엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙들 - 이 규칙들은 순서대로 적용돼야한다.
        
1.  본문을 갖는 것이 허용되지 않는 특정 타입의 http 메시지에선 content-length 헤더가 무시된다.
    
    -   이 경우 content-length 헤더는 부가정보에 불과하고, 실제 본문 길이를 작성하지 않는다.(안이하게 만든 http 애플리케이션은 content-length가 언제나 본문이 있음을 의미한다고 가정해서 난감한 상황에 빠지기도 한다)
    -   ex) HEAD 응답
        -   HEAD 메서드는 응답에서 본문은 제외하고 헤더들만 보내라고 서버에게 요청한다.
        -   HEAD 응답은 본문을 갖지 않는다.
    -   엔터티 본문을 금지하는 메시지는 반드시 헤더 이후의 첫 번째 빈 줄에서 끝나야 한다.
2.  메시지가 transfer-encoding 헤더를 포함하면 → 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ‘0 바이트 청크’라는 특별한 패턴으로 끝나야 한다.
3.  본문을 갖는 것이 허용되는 타입의 메시지이고 && 메시지가 content-length 헤더를 갖는다면 → transfer-encoding 헤더가 존재하지 않는 이상 content-length 값은 본문의 길이다.
    
    transfer-encoding 헤더 필드를 가진 메시지를 받으면 → 반드시 content-length 헤더를 무시해야 한다. 왜냐하면 ← 전송 인코딩은 엔터티 본문을 표현하고 전송하는 방식을 바꿀 것이기 때문이다. + 아마 전송된 바이트 크기도
    
4.  메시지가 multipart/byteranges 미디어 타입을 사용하고
    
    
5.  위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.
    
    오직 서버만이 메시지가 끝났음을 알리기 위해 커넥션을 닫을 수 있다.
    
    클라는 클라 메시지가 끝났다는 신호를 위해 커넥션을 닫을 수 없다. ← 커넥션을 닫으면 서버가 응답을 돌려줄 방법이 없기 때문에
    
6.  http/1.0 애플리케이션과의 호환을 위해, 서버가 http/1.1과 호환된다고 알려져 있지 않다면, 엔터티 본문을 갖고 있는 http/1.1 요청은 반드시 유효한 content-length 헤더를 가져야 한다.
        
        
##   15.3 엔터티 요약 digest

-   메시지 본문(엔터티 바디)의 해시 요약값을 포함해서, 클라이언트나 서버가 데이터가 변조되지 않았는지를 검증할 수 있게 도와줘.
    
-   http가 tcp/ip와 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, (불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시 등의 이유로) 메시지의 일부분이 전송 중에 변형이 되기도 한다.
    
    엔터티 본문 데이터에 대해 의도치 않은 변경을 감지하기 위해 → 최초 엔터티가 생성될 때, 송신자는 데이터에 대한 체크섬을 생성할 수 있고, 수신자는 그 체크섬으로 기본적인 검사를 할 수 있다.
    
-   content-md5 헤더
    
    -   서버가 엔터티 본문에 md5 알고리즘을 적용한 결과를 보내기 위해 사용한다
        
    -   응답을 처음 만든 서버만 content-md5 헤더를 계산해서 보낼 것이다.
        
        중간에 있는 프락시와 캐시는 그 헤더를 변경하거나 추가하지 않을 것이다. ← 종단 간 end-to-end 무결성을 검증하겠다는 목적을 손상시킬 것이기 때문
        
    -   는 콘텐츠 인코딩은 끝났지만 전송 인코딩은 아직 하지 않은 엔터티 본문에 대한 md5를 담는다.
        
    -   메시지의 무결성을 검증하려는 클라이언트는
        
        1.  먼저 전송 인코딩을 디코딩 한 뒤
        2.  디코딩 된 엔터티 본문에 대해 md5를 계산해야 한다.
        
        ex) 어떤 문서를 gzip 알고리즘으로 압축하여 청크 인코딩으로 보냈다면, md5 알고리즘은 압축된 본문 전체에 대해 수행된다.
        
    -   md5
        
        -   로 무결성 검사할 수 있음
        -   로 문서의 위치를 빠르게 알아낼 수 있음
        -   는 콘텐츠의 중복 저장 방지를 위한 해시 테이블의 키로 이용될 수 있다.
        -   ^ 이렇게 활용될 수 있음에도 불구하고, content-md5 헤더는 그다지 자주 전송되지 않는다.


##   15.4 미디어 타입과 charset

-   content-type 헤더 필드
    -   는 엔터티 본문의 MIME 타입을 작성한다.
        
    -   값은 IANA에 등록된 표준화된 mime 타입.
        
    -   에서 흔히 쓰이는 mime 타입
        
        -   text/html
            -   엔터티 본문은 html 문서
        -   text/plain
            -   엔터티 본문은 플레인 텍스트 문서
        -   image/gif
            -   엔터티 본문은 gif 이미지
        -   image/jpeg
            -   엔터티 본문은 jpeg 이미지
    -   가 원본 엔터티 본문의 미디어 타입을 명시한다는 것은 중요하다.
        
        ex) 엔터티가 콘텐츠 인코딩을 거친 후에도 content-type 헤더는 여전히 인코딩 전의 엔터티 본문 타입을 가질 것이다.
        
###   15.4.1 텍스트 매체를 위한 문자 인코딩
   
   -   content-type 헤더는 타입을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다.
       
       ex) charset - 엔터티 비트 집합을 텍스트 파일의 글자들로 변환
       
       ```tsx
       content-type: text/html;charset=iso-8859-4
       ```
       
###   15.4.2 멀티파트 미디어 타입
   
   -   mime 멀티파트 이메일 메시지는 붙어 있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 전송된다.
       
       각 구성요소는 자신에 대해 설명하는 헤더를 포함한다.
       
       여러 구성요소들이 이어져 있고, 문자열 하나고 서로의 경계가 식별된다.
       
   -   http는 멀티파트 본문도 지원한다. 그러나 일반적으로 2가지 경우에만 사용된다.
       
       ###   15.4.3 멀티파트 폼 제출
       -   http 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 구성 요소가 되어 보내진다.
           
           -   가변 길이 텍스트 필드 - 폼에 입력된 일반 텍스트 데이터(예: 사용자 이름, 댓글 내용 등)가 하나의 파트가 됩니다. 이 파트 안에는 해당 필드의 이름과 사용자가 입력한 텍스트 값이 담깁니다. 텍스트의 길이가 가변적이라는 의미입니다.
           -   업로드 될 객체 - 사용자가 선택한 파일(이미지, 문서 등)이 또 다른 하나의 파트가 됩니다. 이 파트 안에는 파일의 이름, MIME 타입, 그리고 실제 파일의 이진 데이터가 담깁니다. 파일 역시 크기(길이)가 가변적입니다.
           
           멀티파트 본문은 여러 종류와 길이로 채워진 폼을 허용한다.
           
           http는 요청을 content-type: multipart/form-data나 content-type: multipart/mixed 헤더에 멀티파트 본문을 함께 보낸다.
           
           ```tsx
           Content-Type: multipart/form-data; boundary=3d6b6a416f9b5
           ```
           
           -   `boundary`
               -   본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

       ###   15.4.4 멀티파트 범위 응답
       -   문서의 일부분을 실어 나르는 범위 응답을 할 때
       -   범위 요청에 대한 http 응답도 멀티파트가 될 수 있다.
       -   content-type: multipart/byteranges 헤더와 (각각 다른 범위를 담는) 멀티파트 본문이 함께 온다.


##   15.5 콘텐츠 인코딩

-   공간을 적게 차지하고, 더 안전하게 만들기 위해 발송자가 콘텐츠 데이터 포맷을 변형할 때 사용한다
    
    -   http는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록 → 엔터티 본문을 인코딩할 수 있게 해준다.
-   디코딩 가능하다
    
-   http 애플리케이션은 때로 콘텐츠를 보내기 전에 인코딩을 한다.
    
    ex)
    
    -   느린 속도로 연결된 클라에게 큰 html 문서를 전송하기 전에 전송 시간을 줄이기 위해 서버는 압축 할 수 있다.
    -   허가받지 않은 제삼자가 볼 수 없도록 서버는 콘텐츠를 암호화해서 보낼 수 있다.
    
    위와 같은 인코딩은 발송하는 쪽에서 콘텐츠에 적용한다. 콘텐츠 인코딩이 끝난 데이터는 엔터티 본문에 담아 수신자에게 보낸다.
    
-   콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연결돼 있다.
    
    ex) 텍스트 파일을 흔히 gzip으로 압축하지만, jpeg 파일은 gzip으로 잘 압축되지 않기 때문에 → 그렇게 압축하지 않는다.
    
###   15.5.1 콘텐츠 인코딩 과정

1.  웹 서버가 원본 content-type과 content-length 헤더를 포함한 원본 응답 메시지를 생성한다
    
2.  콘텐츠 인코딩 서버(아마 원 서버나 프락시일 것이다)는 인코딩된 메시지를 생성한다. content-type은 같지만, content-length는 다르다(본문이 압축 등 됐으면).
    
    콘텐츠 인코딩 서버는 content-encoding 헤더를 인코딩된 메시지에 추가하여 → 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다.
    
3.  수신 애플리케이션은 인코딩된 메시지는 받아서 → 디코딩하고 원본을 얻는다.
    

-   ex)
    
    1.  더 작은 압축된 본문을 만들기 위해 gzip 콘텐츠 인코더를 통해 인코딩된 html 페이지는 네트워크를 통해 전송된다.
        
        이때 압축된 본문엔 gzip 인코딩 플래그가 붙어 있다.
        
    2.  클라는 그 엔터티를 gzip 디코더를 사용해서 압축을 푼다.
        
###   15.5.2 콘텐츠 인코딩 유형

-   http는 표준 콘텐츠 인코딩 타입을 정의하고, 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
-   IANA는 각 콘텐츠 인코딩 알고리즘에 대해 표준화된, 고유한 "토큰" (이름)을 할당하고 공식적으로 등록합니다.
-   흔히 쓰이는 콘텐츠 인코딩 토큰 / 값
    -   gzip
        -   엔터티에 GNU zip 인코딩이 적용되었음을 의미
    -   compress
        -   엔터티에 compress가 실행됐음을 의미
-   gzip, compress 인코딩은 (전송되는 메시지의 크기를 정보의 손실 없이 줄이는) 무손실 압축 알고리즘이다.

###   15.5.3 accept-encoding 헤더
    
-   프론트엔드 개발자에게 매우 중요한 성능 최적화 요소다
    
-   서버가 클라가 지원하지 않는 인코딩을 사용하는 것을 막기 위해 → 클라이언트가 서버에게 자신이 지원하는 압축 방식들 / 인코딩 목록(쉼표로 구분됨)을 accept-encoding을 통해 알려준다.
    
-   만약 http 요청에 accept-encoding 헤더를 포함하지 않거나 accept-encoding: *을 포함하면 → 서버는 클라가 어떤 인코딩이든 받아들일 수 있는 것으로 간주한다.
        
##   15.6 전송 인코딩과 청크 인코딩 chunk encoding

-   전송 인코딩
    
    -   특정 종류의 콘텐츠의 송수신을 개선하기 위해 → http가 (메시지) 데이터를 실어 나르는 방식을 수정한다. → 이를 위해 전송 인코딩을 메시지에 적용할 수 있다
        
###   15.6.1 안전한 전송

-   전송 인코딩은 http 외의 다른 프로토콜에서도 네트워크를 통한 안전한 전송을 위해 존재했다.
-   http에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유
    -   알 수 없는 크기
        
        몇몇 게이트웨이와 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않으면 메시지 본문의 최종 크기를 판단할 수 없다. 흔히 이 서버들은 그 사이즈를 알기 전에 데이터를 전송하려한다.
        
        http는 content-length 헤더를 요구하기 때문에 몇몇 서버는 이 헤더를 포함시켜 전송 인코딩으로 데이터를 보내려고 한다.
        
    -   보안
        
        공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 → 알아보기 어렵게 뒤섞어버리는 방법이 있다. 하지만 이미 ssl과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않다.
        
###   15.6.2 transfer-encoding 헤더

-   전송 인코딩을 제어하기 위한 헤더는 2개뿐이다.
    
    -   **transfer-encoding**
    -   **TE**
        -   어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 포함한다.
-   메시지 본문의 길이를 알 수 없을때 주로 사용한다
    
-   HTTP 메시지 본문을 네트워크를 통해 전송하는 방식에 대해 작성한다.
    
-   안전한 전송을 위해 어떤 인코딩이 메시지에 적용됐는지 수신자에게 알려준다
    
-   수신자에게 메시지가 청크 인코딩으로 전송 인코딩됐음을 알려주기 위해 사용한다
    
###   15.6.3 청크 인코딩

 _청크 인코딩은 웹 서버 구현할때 처음 안 개념인데 잘 기억안나서 다시 공부해야돼_
    
-   길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 조각으로 쪼개 전달한다
    
-   청크 인코딩을 사용하면 → 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.
    
-   본문 전체를 모두 보낼 때까지 다음 단계를 반복한다.
    
    -   메시지를 일정 크기의 여러 청크로 쪼갠다.
    -   본문이 동적으로 생성됨에 따라, 서버는 그 중 일부를 버퍼에 담은 뒤 → 그 중 한 청크를 그것의 크기와 함께 보낼 수 있다.
-   청크 인코딩은 전송 인코딩의 한 형태이며, 본문이 아닌 메시지의 속성이다.
    
    cf) 멀티파트 인코딩은 본문의 속성이다
    

###   15.6.4 콘텐츠와 전송 인코딩의 조합

-   콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.
    
-   ex)
    송신자는
        -   콘텐츠 인코딩을 사용해서 html 파일을 압축하고
        -   전송 인코딩을 사용해서 청크 데이터를 전송한다
###   15.6.5 전송 인코딩 규칙

-   전송 인코딩이 메시지 본문에 적용될 때 반드시 적용돼야 할 규칙
    
    -   transfer-encoding 헤더에 ‘chunked’ 인코딩이 포함돼야하고, 다른 인코딩 방식이 있으면 ‘chunked’가 항상 마지막에 작성돼야 합니다.
        
        -   ex) Transfer-Encoding: gzip, chunked
    -   전송 인코딩의 집합은 반드시 ‘chunked’를 포함해야 한다.
        
        HTTP/1.1에서 전송 인코딩을 사용할 때는 다른 인코딩(gzip, deflate 등)과 함께 사용하더라도 반드시 chunked 인코딩이 포함되어야 합니다.
        
        ```
        Transfer-Encoding: gzip, chunked  ✓ 올바름
        Transfer-Encoding: gzip          ✗ 잘못됨 (chunked 없음)
        Transfer-Encoding: chunked       ✓ 올바름
        ```
        
        유일한 예외: 커넥션이 종료되면서 메시지가 끝나는 경우입니다. 이때는 커넥션 종료 자체가 메시지의 끝을 알리므로 chunked가 없어도 됩니다.
        
    -   청크 전송 인코딩이 사용됐다면 → 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
        
        여러 전송 인코딩을 사용할 때, chunked는 반드시 가장 마지막에 적용되어야 합니다.
        
        ```tsx
        Transfer-Encoding: gzip, chunked  ✓ 올바름 (chunked가 마지막)
        Transfer-Encoding: chunked, gzip  ✗ 잘못됨 (chunked가 마지막이 아님)
        ```
        
    -   청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용돼야 한다.
        
        **메시지 본문에 실제로 청크 인코딩이 적용되어야 합니다.**
        
        ```
        HTTP/1.1 200 OK
        Transfer-Encoding: chunked
        
        4\\r\\n        # 4바이트 청크 크기
        test\\r\\n     # 실제 데이터
        0\\r\\n        # 마지막 청크 (크기 0)
        \\r\\n         # 메시지 끝
        ```
        
    
    ----------
    
    이 규칙은 수신자가 메시지의 전송 길이를 알아낼 수 있게 해준다.
        
##   15.7 시간에 따라 바뀌는 인스턴스

-   웹 객체는 정적이지 않다. 같은 url은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.
    
    ex) cnn 홈페이지
    
    -   하루에 몇 차례 cnn.com에 방문하면 매번 다른 결과를 얻을 수 있다.
    -   cnn 홈페이지를 하나의 객체라고 생각하고, 그것의 다른 버전을 객체의 각각 다른 인스턴스라고 생각해보자.
    -   클라이언트는 같은 리소스(url)을 여러번 요청했는데, 시간의 흐름에 따라 리소스의 다른 인스턴스를 받게 된다.

-   인스턴스 조작 instance manipulation
    
    -   http가 어떤 특정한 종류의 요청이나 응답을 다루는 방법을 정의하는 것
        
    -   객체의 인스턴스에 작용한다.
        
    -   대표적인 두 가지:
        
        -   범위 요청
        -   델타 인코딩
        
        ----------
        
        범위 요청과 델타 인코딩을 쓰려면, 클라이언트가 갖고 있는 리소스가 서버의 것과 정확히 같은지 판단할 수 있어야 한다. 그래야 바뀐 부분만 받거나, 이어서 받을 수 있으니까.
        
##   15.8 검사기와 신선도
    
-   태그, 라벨, 시간, 체크섬은 클라가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와준다.
    
    -   체크섬은 엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있는지 탐지하기 위해 사용한다.
-   검사기들은
    
    -   콘텐츠의 버전 번호처럼 동작한다
    -   웹 애플리케이션에게 그들이 최신 콘텐츠를 가지고 있음을 확신할 수 있게 해준다

###   15.8.1 신선도

-   서버는 클라에게 얼마나 오랫동안 콘텐츠를 캐시하고, 그것이 신선하다고 가정할 수 있는지에 대한 정보를 줄 것이다. by 서버 using expires나 cache-control 헤더


###   15.8.2 조건부 요청과 검사기
    
-   캐시의 사본이 요청됐을 때 그것이 더 이상 신선하지 않으면 → 캐시는 자신이 가진 사본을 신선한 것으로 만들어야 한다.
    
    캐시는 원 서버에서 현 시점의 사본을 가져올 수 있지만, 대개 서버에 있는 문서는 여전히 캐시에 있는 신선하지 않은 사본과 같을 것이다. 캐시된 사본은 만료될 수 있지만, 서버 콘텐츠는 여전히 캐시 콘텐츠와 같을 수 있다.
    
    만약 서버의 문서가 캐시가 갖고 있는 것과 같음에도 불구하고 항상 그 문서를 가져온다면 → 캐시는 네트워크의 대역폭을 낭비하고, 캐시와 서버에 불필요한 부하를 주고, 모든 것을 느려지게 만든다.
    
    이를 고치기 위해, http는 조건부 요청을 제공한다.
    
-   각 조건부 요청은 특정 검사기 위에서 동작한다.
    
-   검사기 ex) 일련 번호, 버전 번호, 문서의 최종 변경일, last-modified, etag
    
-   조건부 헤더와 조건부 헤더에 의해 사용되는 검사기
    
    -   if-modified-since 헤더는 문서 인스턴스의 마지막 수정된 날짜를 검사하므로 → 마지막 수정된 날짜를 검사기라고 말할 수 있다.
    -   if-none-match 헤더는 문서의 etag값을 평가한다.
-   클라와 서버는 때로 엔터티 태그 검사를 통과하지 못한 버전을 채택하는 경우가 있다.
    
    -   ex) 서버는 크고 자주 찾는 캐시된 문서에 대해, 캐시의 재검사로 인한 대량 전송을 유발하지 않으면서 겉모양만 약간 고치고 싶을 수도 있다.
        -   예를 들어, 웹사이트의 메인 페이지 HTML 파일처럼 용량이 크고 사용자들이 자주 접근하여 캐시에 많이 저장되는 리소스.
        -   리소스의 내용 자체는 크게 변하지 않았지만, 예를 들어 주석을 추가하거나, HTML 태그의 속성 순서만 바꾸거나, 이미지 경로를 약간 수정하는 등 의미상으로는 동일하거나 매우 사소한 변경이 발생한 경우
        -   `ETag`는 기본적으로 "강한 검사기"이기 때문에, 내용이 한 글자라도 바뀌면 `ETag` 값이 변경됩니다. 이 경우 클라이언트가 `If-None-Match`로 요청해도 `ETag`가 다르므로 서버는 `200 OK`와 함께 전체 대량의 리소스를 다시 전송하게 됩니다. 이는 네트워크 대역폭 낭비와 서버 부하 증가로 이어집니다.
    -   이 경우 서버는 태그 앞에 ‘W/’를 붙여서 → 약한 엔터티 태그임을 나타낸다. 약한 엔터티 태그는 (엔터티의 의미상) 두드러진 변화에만 사용할 수 있다.
        -   cf) 강한 엔터티 태그는 관련된 엔터티 값이 아무리 사소하게 바뀌었더라도 함께 변경돼야한다.


##   15.9 범위 요청 range request

-   중단됐던 다운로드를 중단된 지점부터 재개하고자 할 때 유용하다
    
-   `Range` 헤더를 사용해 파일의 특정 바이트 범위만 요청합니다. 서버가 이를 지원하면 `206 Partial Content` 상태 코드와 함께 요청된 부분만 응답합니다.
    
    ```
    GET /video.mp4 HTTP/1.1
    Range: bytes=0-1023
    ```
    
-   범위 요청을 사용하기 전에 서버가 지원하는지 확인해야 합니다:
    
    ```jsx
    async function checkRangeSupport(url) {
      const response = await fetch(url, { method: 'HEAD' });
      return response.headers.get('Accept-Ranges') === 'bytes';
    }
    ```
    
-   http는 클라가 문서의 특정 범위만 요청할 수 있도록 해준다.
    
-   http 클라는 받다가 실패한 엔터티를 범위로 요청함으로써 / 범위 요청을 이용해서 → 다운로드가 중단된 시점에서 재개할 수 있다.(원 서버에서 그 객체에 처음 요청했을 때와 범위 요청을 했을 때 사이에 아무 변경이 없었다면)
    
-   ex)
    -   클라는 처음 4000 바이트 이후의 부분을 요청
    -   요청차가 문서의 크기를 모르기 때문에 → 몇 바이트까지인지는 명시하지 않음
    -   이 형식의 범위 요청은 클라가 처음의 4000 바이트만 받고 실패했을 때 사용할 수 있다.
-   모든 서버가 범위 요청을 받아들일 수 있는 건 아님(많은 경우에 가능함) → 서버는 클라에게 자신이 범위 요청을 받아들일 수 있는지 알려줄 수 있다. by 응답에 accept-range 헤더를 포함시켜서.
    
    -   accept-range 값 : 측정의 단위.
        
        -   주로 바이트임.
        
-   클라의 범위 요청은 오직 클라와 서버가 같은 문서를 갖고 있을 때만 의미가 있음

##   15.10 델타 인코딩 delta encoding

-   델타 = 변경된 부분
-   클라가 전에 본 적이 있었던 웹 페이지를 다시 볼 때, 그때 이후로 변경이 있는 부분만 요청할 수 있게 해준다
    
-   델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신해서 → 전송량을 최적화한다.
    
-   델타 인코딩의 메커니즘
    
    -   클라는 페이지의 어떤 버전을 갖고 있는지 서버에게 말해줘야 한다. 이는 클라가 페이지의 최신 버전에 대한 델타를 받아들일 의사가 있음을 의미한다.
        
    -   클라는 자신이 갖고 있는 현재 버전에 델타를 적용하기 위해 어떤 알고리즘을 알고 있는지도 서버에게 말해줘야 한다
        
        -   서버는 자신이 클라가 갖고 있는 버전을 갖고 있는지, 어떻게 최신 버전과 클라의 버전 사이의 델타를 계산할 것인지 확인해야 한다.(두 객체의 차이를 계산하는 알고리즘이 여러 개 존재한다.)
            
            그리고 델타를 계산해서 클라에게 보내주고, 서버가 델타를 보내고 있음을 클라에게 알려주고, 페이지의 최신 버전에 대한 새 식별자를 명시해야 한다.
            
    -   클라는
        
        -   자신이 갖고 있는 버전에 대한 식별자(저번 응답에서의 etag)를 if-none-match 헤더에 담는다. = 서버에게 ‘네가 갖고 있는 최신 버전의 페이지가 이것과 같은 etag를 갖고 있지 않다면, 최신 버전의 페이지를 보내줘’
            
            if-none-match 헤더에 의해 서버는 클라에게 그 페이지의 최신 버전 전체를 보낼것이다.
            
        -   서버에게 A-IM 헤더를 보낼 수도 있다.
            
            1.  a-im 헤더에 자신이 아는 페이지의 예전 버전과 델타를 이용해 최신 버전의 문서를 생성하는 알고리즘을 명시한다.
            2.  서버는 클라에게 아래의 것들을 전송한다.
                -   226 im used 응답코드 - 요청한 객체에 대해 객체 자체가 아닌 인스턴스 조작을 보내고 있음을 말해준다
                -   IM 헤더 - 델타를 계산할때 사용된 알고리즘을 명시
                -   새 etag 헤더
                -   delta-base 헤더 - 델타를 계산할 때 기반이 된 문서의 etag를 명시

### 인스턴스 조작, 델타 생성기 그리고 델타 적용기

-   클라는 a-im 헤더를 사용해서 → 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있다.
    
-   서버는 im 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있다.
    
-   iana에 등록된 인스턴스 조작의 종류
    
    -   diffe - 유닉스 diff -e 명령을 이용한 델타
    -   gzip - gzip 알고리즘을 이용한 압축
    -   range - 현재 응답이 범위 선택에 대한 결과(부분 콘텐츠)임을 말해주기 위함. 서버 응답에서 사용됨
-   서버의 델타 생성기
    
    -   기저 문서와 그 문서의 최신 인스턴스로 클라의 a-im 헤더에 지정된 알고리즘을 사용해 둘 사이의 델타를 계산한다.
-   클라에선 델타 적용기가 델타를 기저 문서에 적용해서 문서의 최신 인스턴스를 생성한다.
    

	ex) 델타를 생성하기 위해 사용된 알고리즘이 유닉스 diff -e 명령이라면, 클라는 유닉스 ed 편집기의 기능을 이용해서 델타를 적용할 수 있다.

-   문서는 클라에게 반환하기 전에 압축률을 극대화하기 위해 여러 번의 인스턴스 조작을 거칠 수 있다.
    
    ex)
    
    -   vcdiff 알고리즘에 의해 생성된 델타는 gzip 알고리즘을 이용해 압축될 수 있다. 그 다음에 서버 응답은 `IM: vcdiff, zip` 헤더를 포함할 것이다.
    -   클라는 gunzip으로 콘텐츠의 압축을 풀고 이 결과로 얻은 델타를 기저 페이지에 적용해서 최종 문서를 얻는다.
-   델타 인코딩은 문서를 제공하는 데 걸리는 시간을 / 전송 시간을 줄일 수 있지만, 구현하기가 까다로울 수 있고, 서버는 문서의 과거 사본을 모두 유지하기 위해 디스크 공간을 더 늘려야 한다.
    
    -   ex) 변경이 잦고 많은 사람이 접근하는 페이지
        -   델타 인코딩을 지원하는 서버는 변경점만을 보내는 것을 가능하도록 하기 위해 자신이 제공하는 페이지의 변경 사본을 모두 유지하고 있어야 한다 / 반드시 클라가 갖고 있던 이전 버전의 사본들 모두를 유지해야만 한다.
        -   문서가 자주 변경된다면, 문서를 요청하는 클라이언트마다 문서에 대한 각각 다른 인스턴스를 받게 될 것이다.
