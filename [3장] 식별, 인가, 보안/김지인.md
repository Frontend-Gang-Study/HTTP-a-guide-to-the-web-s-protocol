#   11장 클라이언트 식별과 쿠키

-   웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다. 서버는 익명의 클라이언트로부터 받는 모든 요청을 처리 + 서버와 통신하고 있는 클라이언트를 추적해야할 수도 있다.

-   이 장에선 http 서버가 통신하는 대상 / 사용자를 식별해서 콘텐츠를 개인화시키는 데 사용하는 기술에 대해 알아볼거다.

##   11.1 개별 접촉

-   http는 익명으로 사용하며, 상태가 없고, 요청과 응답으로 통신한다.
    
-   웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.
    
-   현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어한다. 네트워크로 연결된 사용자들에 대해 더 많은 것을 알고 싶어 하고, 사용자들이 브라우징하는 것을 기록하고 싶어 한다.
    
    [amazon.com](http://amazon.com) 같이 유명한 온라인 쇼핑 사이트는 여러가지 방식으로 사이트를 개인화 시켜서 사용자에게 제공한다.
    
    -   개별 인사
        -   온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다
    -   사용자 맞춤 추천
        -   온라인 상점은 고객의 흥미가 무엇인지 학습해서 → 고객이 좋아할 것이라고 예상되는 제품들을 추천할 수 있다. 고객의 생일이나 다른 중요한 날이 다가오면 특별한 제품을 제시하기도 한다.
    -   저장된 사용자 정보 사용
        -   온라인 쇼핑 고객은 복잡한 주소와 신용카드 정보를 매번 입력하는 것을 싫어한다. 이런 정보를 데이터베이스에 저장하는 온라인상점도 있다. 온라인 쇼핑몰이 당신을 한번 식별하고 나면, 쇼핑을 더 편하게 할 수 있게 저장된 사용자 정보를 사용할 수 있다.
    -   세션 추적
        -   http 트랜잭션은 상태가 없다. 각 요청 및 응답은 독립적으로 일어난다. 많은 웹사이트에서 사용자가 사이트와 상호작용할 수 있게 사용자의 상태를 남긴다. ex) 장바구니. 이렇게 상태를 유지하려면, 웹 사이트는 각 사용자에게서 오는 http 트랜잭션을 식별할 방법이 필요하다.
        
##   11.2 http 헤더

-   사용자 관련 식별 관련 정보를 전달한다
    
-   사용자에 대한 정보를 전달하는 가장 일반적인 http 요청 헤더
    | 헤더 이름 | 헤더 타입 | 설명 |
	|-----------|-----------|------|
	| From | 요청 | 사용자의 이메일 주소 |
	| User-Agent | 요청 | 사용자의 브라우저 |
	| Referer | 요청 | 사용자가 현재 링크를 타고 온 페이지 |
	| Authorization | 요청 | 사용자 이름과 비번 |
	| Client-ip | 확장(요청) | 클라이언트의 ip 주소 |
	| X-Forwarded-For | 확장(요청) | 클라이언트의 ip 주소 |
	| Cookie | 확장(요청) | 서버가 생성한 id 라벨 |
  
    
    -   From
        
        -   사용자의 이메일 주소를 포함한다.
        -   각 사용자가 서로 다른 이메일 주소를 가지므로 → 이 헤더로 사용자를 식별할 수 있다
        -   단점 : 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 → 이 헤더를 보내는 브라우저는 많지 않다.
        -   로봇이나 스파이더는 데이터를 수집하는 과정에서 본의 아니게 웹 사이트에 문제를 일으켰을 때 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 이 헤더에 이메일 주소를 작성한다.
    -   User-Agent
        
        -   사용자가 쓰고 있는 브라우저의 이름과 정보, 어떤 경우엔 운영체제에 대한 정보를 포함
            
        -   특정 브라우저에서 제대로 동작하도록 콘텐츠를 죄적화하는 데 유용할 수 있지만, 특정 사용자를 식별하는 데는 큰 도움이 되지 않는다
            
        -   ex) 구글 크롬
            
            ```bash
            user-agent:
            Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36
            ```
            
    -   Referer
        
        -   사용자를 현재 페이지로 유입하게 한 웹페이지의 url을 가리킨다
            
        -   이 헤더 자체만으로 사용자를 식별할 수는 없지만, 사용자가 이전에 어떤 페이지를 방문했었는지 알려준다.
            
            이 헤더를 통해서 사용자의 웹 사용 행태나 사용자의 취향을 더 잘 파악할 수 있다.
            
            ex) 야구 사이트에서 현재 웹 서버로 접근한 것이라면, 서버는 접속한 사용자가 야구 애호가라고 유추할 수 있다.
            
##   11.3 클라이언트 ip 주소

-   클라이언트 ip 주소 추적으로 알아낸 ip 주소로 사용자를 식별
    
-   초기 웹 선구자들은 사용자 식별에 클라이언트 ip 주소를 사용하려 했다. 이 방식은 사용자가 확실한 ip 주소를 가지고 있고, 그 주소가 좀처럼 바뀌지 않고, 웹 서버가 요청마다 클라이언트의 ip를 알 수 있다면 문제 없이 동작한다.
    
-   클라이언트의 ip 주소는 보통 http 헤더에 없지만, 웹 서버는 http 요청을 보내는 반대쪽 tcp 커넥션의 ip 주소를 알아낼 수 있다.
    
    ex) 유닉스 시스템에서 getpeername 함수를 호출하면 요청을 보낸 클라이언트의 ip 주소를 받을 수 있다.
    
-   클라이언트 ip 주소로 사용자를 식별하는 방식의 문제점
    
    -   클라이언트 ip 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킨다. 만약 여러 사용자가 같은 컴퓨터를 사용한다면 → 그들을 식별할 수 없을 것이다.
        
    -   많은 인터넷 서비스 제공자 ISP는 사용자가 로그인하면 동적으로 ip 주소를 할당한다. 로그인한 시간이 따라 사용자는 매번 다른 주소를 받으므로 → 웹 서버는 사용자를 ip 주소로 식별할 수 없다.
        
    -   보안을 강화하려고 많은 사용자가 네트워크 주소 변환 network address translation NAT 방화벽을 통해 인터넷을 사용한다. 이 NAT 장비들은 클라이언트의 실제 ip 주소를 방화벽 뒤로 숨기고, 클라이언트의 실제 ip 주소를 내부에서 사용하는 하나의 방화벽 ip 주소로 변환한다.
        
        보안을 강화하려고 사용자가 네트워크 주소 변환 NAT 방화벽을 사용할 수 있는데, 이 NAT 장비들은 여러 클라이언트들의 ip 주소를 하나의 공용 ip 주소로 변환한다. 그러면 서버에선 여러 사용자를 동일한 ip로 인식해서 → 개별 사용자 식별 불가능
        
    -   보통 http 프락시와 게이트웨이는 원 서버에 새로운 tcp 연결을 한다. 웹 서버는 클라이언트의 ip 주소 대신 프락시의 ip 주소를 본다. 일부 프락시는 원본 ip 주소를 보존하려고 client-ip나 x-forwarded-for 같은 확장 헤더를 추가해서 이 문제를 해결하려고 한다. 하지만 모든 프락시가 이런식으로 동작하지는 않는다.
        
-   어떤 사이트는 보안 기능으로 ip 주소를 사용해서 → 특정 ip 주소로부터 오는 사용자에게만 문서를 전달하기도 한다. 이 방식은 인트라넷 같이 제한된 영역에선 적절할 수 있지만, 인터넷에선 ip 주소를 임의로 변경할 수 있기 때문에 문제가 발생할 수 있다.
    
##   11.4 사용자 로그인

-   웹 서버는 사용자 로그인 인증(사용자 이름과 비번으로 인증)할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
    
-   웹 사이트 로그인이 더 쉽도록 http는 authorization, www-authenticate 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
    
-   한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 → 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.
    
-   ex) 서버에서 사용자가 사이트에 접근하지 전에 로그인을 시키는 웹 애플리케이션
    
    1.  브라우저는 [www.joes-hardware.com](http://www.joes-hardware.com) 사이트로 요청을 보낸다
        
    2.  사이트는 사용자의 식별 정보를 알지 못하므로 서버는 401 login required와 www-authenticate 헤더를 반환하여 로그인하라고 요청한다. 이는 브라우저에 로그인 ui를 띄우게 한다.
        
    3.  사용자가 사용자 이름과 비번을 입력하고, 브라우저는 기존 요청을 다시 보낸다.
        
    4.  이제 서버는 사용자의 식별 정보를 안다.
        
    5.  이 시점 이후의 요청에 대해서 브라우저는 서버로부터 사용자 식별 정보를 요청 받거나 받지 않았을때 자동으로 사용자 이름과 비번을 포함해서 전달한다.
        
        사이트에 한 번만 로그인하면 브라우저는 요청마다 해당 사용자의 식별 정보 토큰을 authorization 헤더에 담아 서버로 전송해서, 한 세션이 진행되는 내내 그 사용자에 대한 식별을 유지한다.
        
##   11.5 뚱뚱한 url

-   사용자의 상태 정보를 포함하고 있는 url
    
-   url에 식별자를 포함하는 기술이다
    
-   어떤 웹 사이트는 사용자의 url마다 버전을 작성해서 사용자를 식별하고 추적했다.
    
    -   사용자가 사이트를 돌아다니면, 웹 서버는 url에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.
-   보통 Url은 url 경로의 처음이나 끝에 상태 정보를 추가해서 확장한다
    
-   ex) [amazon.com](http://amazon.com) 뚱뚱한 url
    
    -   웹 상점을 돌아다니는 사용자에게 할당된 식별 번호(여기선 002-1145265-8016838)를 각 url 뒤에 붙여서 사용자를 추적한다.
-   웹 서버와 통신하는 독립적인 http 트랜잭션을 하나의 세션 / 방문으로 묶는 용도로 뚱뚱한 url을 사용할 수 있다. 사용자가 웹 사이트에 처음 방문하면 유일한 id가 생성되고, 그 값은 서버가 인식할 수 있는 방식으로 url에 추가되며, 서버는 클라이언트를 이 뚱뚱한 url로 리다이렉트 시킨다. 서버가 뚱뚱한 url을 포함한 요청을 받으면 → 사용자 아이디와 관련된 추가적인 정보(장바구니, 프로필 등)을 찾아서 모든 하이퍼링크를 뚱뚱한 url로 바꾼다.
    
-   뚱뚱한 url은 사용자를 식별하는 데 사용할 수 있지만, 여러 심각한 문제가 있다.
    
    -   못생긴 url
        
        -   브라우저에 보이는 뚱뚱한 url은 새로운 사용자들에게 혼란을 준다
        
        _개발자 말고 보통 사용자는 url 잘 보지 않지 않음?_
        
    -   공유하지 못하는 url
        
        뚱뚱한 url은 특정 사용자와 세션에 대한 상태 정보를 포함한다. 만약 그 주소를 누군가에게 공유하면, 당신의 누적된 개인 정보를 본의 아니게 공유하게 된다.
        
    -   캐시를 사용할 수 없음
        
        -   url이 달라지기 때문에 기존 캐시에 접근할 수 없다
    -   서버 부하 가중
        
        -   서버는 뚱뚱한 url에 해당하는 html 페이지를 다시 그려야 한다.
    -   이탈
        
    -   세션 간 지속성의 부재
        
        -   사용자가 특정 뚱뚱한 url을 북마킹하지 않으면 로그아웃 하고 나서는 모든 정보를 잃는다.

##   11.6 쿠키

-   식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술
    
-   쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용됨
    
-   쿠키만으로 하기 힘든 일에는 위 기술들(11.3~11.5)을 함께 사용하기도 한다.
    
-   넷스케이프가 최초로 개발했지만 지금은 모든 브라우저에서 지원함
    
-   매우 중요한 웹 기술
    
-   새로운 http 헤더를 정의한다
    
-   쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않음.
    
###   11.6.1 쿠키의 타입

크게

-   **세션 쿠키 session cookie**
    -   임시 쿠키
    -   사용자가 사이트를 탐색할 때, 선호 사항 등을 저장
    -   사용자가 브라우저를 닫으면 삭제됨
-   **지속 쿠키 persistent cookie**
    -   디스크에 저장됨
    -   브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다
    -   세션 쿠키보다 더 길게 유지될 수 있음.
    -   사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용

로 나눌 수 있음

둘의 차이점은 **파기되는 시점** 뿐. Discard 파라미터가 설정돼있거나 / Expires 또는 Max-Age 파라미터가 없으면 세션쿠키가 된다.

###   11.6.2 쿠키는 어떻게 동작하는가

사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다.

처음에 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해서 아무것도 모른다. 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.

쿠키는 임의의 `이름=값` 형태의 리스트를 가지고, 그 리스트는 Set-Cookie / Set-Cookie2(확장 헤더) 같은 http 응답 헤더에 작성돼 사용자에게 전달한다.

-   쿠키는 어떤 정보든 포함할 수 있음
    -   서버가 사용자 추적 용도로 생성한 유일한 식별 번호만 포함하기도 한다.
        
        ex) 서버는 `id=34294` 라는 쿠키를 사용자에게 할당한다. 서버는 이 쿠키 값으로 데이터베이스에서 사용자의 정보(구매 내용, 주소 정보 등)를 찾는데 사용할 수 있다.

브라우저는 서버로부터 온 Set-Cookie / Set-Cookie2 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장한다.

사용자가 미래에 같은 사이트를 방문하면, 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 작성해 전송한다.

###   11.6.3 쿠키 상자: 클라이언트 측 상태

브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 클라이언트 측 상태(쿠키 명세에서의 공식적인 이름은 http 상태 관리 체계 http state management mechanism) 라고 한다.

각 브라우저는 다른 방식으로 쿠키를 저장한다.

-   구글 크롬 쿠키
    
    Cookies라는 파일에 쿠키를 저장한다.
    
    이 파일에 있는 각 행이 쿠키 한 개에 해당한다.
    
    -   name : 쿠키의 이름
    -   value : 쿠키의 값
    -   path : 쿠키 사용 접근이 가능한 페이지 경로
        -   **해당 경로의 하위 경로까지 모두 포함**한다.
        -   루트 경로 `/` : 모든 경로에서 쿠키가 유효
        -   `path=/home` 지정
            -   `/home/level1` → 접근 가능
            -   `/home/level1/level2` → 접근 가능
            -   `/hello` → 접근불가능 (다른 경로)
        -   기본값 : 루트 경로
            -   path를 입력하지 않으면 루트 경로로 자동 입력 된다.
        -   단, 쿠키의 범위를 좁게 잡을 수록 보안에는 좋다.
        -   동작 과정
            1.  사용자가 특정 URL에 접근할 때, 브라우저가 저장된 쿠키들을 검사합니다.
            2.  브라우저는 각 쿠키의 `path` 속성과 현재 요청하는 URL 경로를 비교합니다.
            3.  Path 조건이 맞으면, 브라우저가 해당 쿠키를 `Cookie` 헤더에 포함해서 서버로 전송합니다.
    -   secure : 해당 쿠키를 SSL 커넥션일 경우에만 보낼지 여부
    -   HttpOnly : 쿠키를 자바스크립트에서 액세스 하지 못하도록 제한. 해커가 자바스크립트로 쿠키를 탈취할수 없어, XSS 공격을 방지할 수 있다.

###   11.6.4 사이트마다 각기 다른 쿠키들

브라우저는

-   수천 개의 쿠키를 가지고 있을 수 있지만, 그렇다고 브라우저가 모든 쿠키를 모든 사이트에 보내지는 않는다.
    
-   보통 각 사이트에 2~3개의 쿠키만 보낸다.
    
-   이유
    
    -   브라우저가 쿠키를 모두 전달하면, 실제 콘텐츠의 바이트보다 더 많은 쿠키 바이트를 전달하는것이기에 성능이 크게 저하된다.
    -   쿠키들 대부분은 특정 서버에 특화된 이름/값 쌍을 포함하기에, 대부분 사이트에서는 인식하지 못하는 무의미한 값이다.
    -   모든 사이트에 쿠키 전체를 전달하는 것은, 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서 개인정보 문제를 일으킬 수 있다.
-   보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.
    
    ex) test.com에서 생성된 쿠키는 test.com에만 보내고, test2.com엔 보내지 않는다.
    
-   많은 웹 사이트는 광고를 관리하는 협력업체와 계약을 한다. 이 광고들은 웹 사이트의 일부인 것처럼 제작되고, **지속 쿠키**를 만들어낸다. 같은 광고사와 연결돼있는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버로 전송한다. 지속 쿠키의 도메인이 같기 때문이다. 광고사는 Referer 헤더를 접목해서 사용자의 프로필과 웹 사이트를 사용하는 습관에 대한 방대한 데이터를 구축할 수 있다.
    
-   최신 브라우저들은 개인정보 설정 기능을 통해 협력 업체의 쿠키 사용 방식에 제약을 걸 수 있도록 한다.
    

### 쿠키 Domain 속성

서버는 쿠키를 생성할 때 Set-cookie 응답 헤더에 domain 속성을 작성해서 **어떤 사이트가 그 쿠키를 읽을 수 있는지 제어**할 수 있다.

ex)

```jsx
Set-cookie: user="jeekim"; domain="test.com"
```

위 http 응답 헤더는 브라우저가 user=”jeekim”이라는 쿠키를 `.test.com` 도메인을 가지고 있는 모든 사이트에 / .test.com으로 끝나는 사이트에 전달한다는 의미다.

만약 사용자가 www.test.com이나 www.test.test.com 같이 `.test.com`으로 끝나는 사이트를 방문하면 아래 Cookie 헤더가 항상 적용될 것이다.

```jsx
Cookie: user="jeekim"
```

### 쿠키 Path 속성

웹 사이트 일부에만 쿠키를 적용할 수 있다. (url 경로의 앞부분을 가리키는) path 속성을 작성해서 해당 경로에 속하는 페이지에만 쿠키를 전달한다.

ex)

[www.test.com](http://www.test.com) 사이트는 자동차를 대여하는 페이지인 [http://www.test.com/autos에서](http://www.test.com/autos%EC%97%90%EC%84%9C) 사용자가 좋아하는 자동차 크기를 기록하려고 쿠키를 사용한다. 자동차 대여에 관한 쿠키는 아래와 같이 생성한다

```jsx
Set-cookie: pref="compact"; domain="test.com"; path="/autos"
```

만약 사용자가 [http://www.test.com/index.html에](http://www.test.com/index.html%EC%97%90) 접근하면 아래와 같은 쿠키만 얻게 된다

```jsx
Cookie: user="jeekim"
```

하지만 사용자가 [http://www.test.com/autos/index.html로](http://www.test.com/autos/index.html%EB%A1%9C) 접근하면 아래와 같은 두 가지 쿠키를 받게 될 것이다.

```jsx
Cookie: user="jeekim"
Cookie: pref="compact"
```

쿠키는 서버가 생성해서 클라이언트에 전달하고, 클라이언트는 그 쿠키를 유효한 사이트에만 전달하고 관리한다.

###   11.6.5 쿠키 구성 요소

현재 사용되는 쿠키 명세에는

-   version 0 쿠키와
-   version 1 쿠키

가 있다.

version 0 쿠키 명세는 http/1.1 명세 일부로 작성돼있지는 않다.

쿠키의 사용법에 대해 가장 잘 나와 있는 참고 자료 : `persistent client state: http cookies` (넷스케이프 쿠키 표준 원문)

###   11.6.6 version 0(넷스케이프) 쿠키

-   흔히 넷스케이프 쿠키라고 부른다.
    
-   최초의 쿠키 명세는 넷스케이프가 정의했다.
    
-   version 0 쿠키는 Set-cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필요한 필드들을 정의했다.
    
-   version 0 쿠키 형태
    
    ```jsx
    Set-cookie: name=value [; expires=date] [; domain=domain] [; path=path] [; secure]
    Cookie: name1=value1 [; name2=value2] ...
    ```
    
-   version 0 Set-cookie 헤더
    
    -   쿠키의 이름과 값을 가져야 한다.
    -   쿠키 옵션 속성들은 세미콜론으로 구분지어 작성한다.
    
	| 속성 | 필수/선택 | 설명 |
	|------|-----------|------|
	| 이름=값 | 필수 | 이름과 값 모두 큰따옴표로 감싸지 않은, 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열<br>`Set-cookie: user=jeekim` |
	| expires | 선택 | 날짜 문자열을 작성. 파기 일자에 다다르면, 그 쿠키는 삭제될 것이며 전달되지도 않을 것이다. 명시하지 않으면 해당 쿠키는 사용자의 세션이 끝날때 파기 된다.<br>날짜 형식 : `요일, DD-MM-YY HH:MM:SS GMT` 사용할 수 있는 타임존은 GMT 뿐. 날짜 요소 간의 구분은 대시`-`여야 함.<br>`Set-cookie: user=jeekim; expires=Mon, 06-Jan-25 09:56:17 GMT` |
	| domain | 선택 | 브라우저는 `Domain` 속성에 지정된 도메인 및 그 하위 도메인에 대해 쿠키를 전송한다.<br>기본값 : Set-cookie 응답을 생성한 서버의 호스트명<br>명시돼있지 않으면 Set-cookie 응답을 생성한 서버의 호스트명을 사용한다. test.com이면 'test.test.com'의 호스트명과는 짝이 맞지만, 'cnn.com'과는 맞지 않다.<br>`Set-cookie: user=jeekim; domain="test.com"` |
	| path | 선택 | 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다. path 속성에 작성된 값이 url 경로의 앞부분과 일치하면 쿠키를 전달한다.<br>`/` 경로는 도메인에 있는 모든 문서에 들어맞는다. '`/foo`' 경로는 '/foobar'과 '/foobar.html'에 들어맞는다.<br>기본값 : Set-cookie 응답을 전달하는 url의 경로<br>명시하지 않으면 Set-cookie 응답을 전달하는 url의 경로가 사용된다<br>`Set-cookie: user=jeekim; path="/autos"` |
	| secure | 선택 | 이 속성이 포함돼있으면 클라이언트가 서버에게 요청을 보낼 때 http가 SSL 보안 연결을 사용할 때만 / HTTPS 연결에서만 쿠키를 전송한다.<br>`Set-cookie: user=jeekim; secure` |
    
-   version 0 Cookie 헤더
    
    클라이언트가 요청을 보낼 때 현재 요청 URL에 맞고 Domain, Path, Secure과 같은 조건들에 맞고 아직 파기되지 않은 쿠키들만 자동으로 포함해서 보낸다.
    
    모든 쿠키는 Cookie 헤더에 이어 붙여 보낸다
    
    ```jsx
    Cookie: session-id=001; session-id-time=1000
    ```
    
###   11.6.7 version 1 (rfc 2965) 쿠키

-   version 1 쿠키는 version 0 쿠키의 확장 버전으로 널리 쓰이지는 않고, 현재는 사용되지 않는다.
-   set-cookie2와 cookie2 헤더를 소개
-   version 0 시스템과도 호환된다
-   넷스케이프 표준(원 버전)보다 좀 더 복잡하다
-   아직 모든 브라우저나 서버가 완전히 지원하지 않는다

###   11.6.8 쿠키와 세션 추적

-   쿠키는 웹 사이트에 수차례 트랜잭션을 만드는 사용자를 추적하는 데 사용한다.
    -   전자상거래 웹 사이트는 사용자가 온라인 쇼핑을 하는 중에도 그들의 장바구니를 유지하려 세션 쿠키를 사용한다.
        
    -   ex) Amazon.com에 방문하면 일어나는 연속 트랜잭션
        
        -   Amazon.com은 세션 쿠키를 이용해서 사용자를 추적한다
        -   (a) 브라우저가 amazon.com의 루트 페이지를 처음 요청한다.
        -   (b) 서버는 클라이언트를 전자상거래 소프트웨어 url로 리다이렉트 시킨다.
        -   (c) 클라이언트는 리다이렉트 url을 요청한다.
        -   (d) 서버는 응답에 2개의 세션 쿠키를 작성하고, 사용자를 다른 url로 이동시킨다.
        -   (e) 클라이언트는 새로운 url 요청을 앞서 받은 2개의 쿠키와 함께 보낸다.
        -   (f) 서버는 home.html 페이지로 리다이렉트 시키고, 쿠키 2개를 더 첨부한다.
        -   (g) 클라이언트는 home.html 페이지를 요청하고, 쿠키 4개를 요청에 포함한다.
        -   (h) 서버는 컨텐츠를 보낸다
###   11.6.9 쿠키와 캐싱

-   쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다. 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수 있다.
-   캐시를 다루는 기본 원칙
    -   캐시되지 말아야 할 문서가 있다면 표시하라
        -   문서를 캐시하면 될지 안 될지는 문서의 소유자가 가장 잘 안다.
            
        -   만약 문서가 Set-cookie 헤더를 제외하고 캐시를 해도 되는 경우 → 그 문서에 명시적으로 cache-control: no-cache=”set-cookie”를 작성한다
            
        -   캐시를 해도 되는 문서에 cache-control: public을 사용하면 웹의 대역폭을 더 절약시켜준다.
            
        -   ex) 공용 캐시에 개인화 응답이 저장된 경우
            
            1.  A 사용자가 로그인한 상태로 `/my-page`에 접속
                
                → 서버는 A의 정보를 포함한 응답을 생성
                
                → 서버가 실수로 이 응답에 `Cache-Control: public`을 설정하거나 아무 캐시 헤더도 설정하지 않음
                
                → 이 응답이 공용 캐시(CDN, 프록시)에 저장됨
                
            2.  B 사용자가 나중에 같은 URL(`/my-page`)에 접속
                
                → 캐시는 "이 경로는 캐싱된 게 있다!"고 생각하고, A의 응답을 그대로 전달
                
                → B는 A의 이름, 이메일, 주문 내역 등을 그대로 보게 됨
                
        -   캐시 금지 대상 민감 정보 목록
            
            -   프로필 페이지와 같이 사용자의 민감한 정보가 들어 있는 페이지
            
    -   set-cookie 헤더를 캐시하는 것에 유의해라
        -   같은 set-cookie 헤더를 여러 사용자에게 보내면, 사용자 추적에 실패할 것이기 때문이다.
            
        -   응답이 set-cookie 헤더를 가지면, 본문은 캐시할 수 있다.
            
        -   어떤 캐시는 응답을 저장하기 전에 set-cookie 헤더를 제거하기 때문에, 그 캐시 데이터를 받는 클라이언트는 set-cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다.
            
        -   캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 set-cookie 헤더 값을 작성해서 이 문제를 해결할 수 있다.
            
            -   원 서버는 아래와 같은 헤더를 캐시된 문서에 추가함으로써 재검사가 일어나게 할 수 있다.
                
                ```tsx
                cache-control: must-revalidate, max-age=0
                ```
                
        -   어떤 캐시는 set-cookie가 있는 이미지를 캐시 하지만, set-cookie가 있는 텍스트는 캐시 하지 않는다.
            
            
-   cookie 헤더를 포함한 요청은 액세스 토큰과 같이 개인 정보를 담고 있는 응답이 올 가능성이 높습니다. 따라서 이런 경우엔 캐시를 저장하지않게 백엔드에 Cache-Control: no-store로 설정하도록 요청할 수 있습니다.
-   프로필 페이지와 같이 사용자의 민감한 정보가 들어 있는 문서는 캐시되지 말아야 함. → Cache-Control: no-store로 캐시 저장을 하지 x

###   11.6.10 쿠키, 보안 그리고 개인정보

-   쿠키를 사용하지 않도록 비활성화 시키는 등의 처리를 할 수 있으므로 → 쿠키 자체가 보안상으로 엄청나게 위험한 것은 아니다.
    
-   원격 데이터베이스에 개인 정보를 저장하고, 해당 데이터의 키 값을 쿠키에 저장하는 방식을 사용하면, 클라이언트와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있다.
    
    _오 cabi datagrip으로 user table의 내 id랑 access token 쿠키에 있는 id랑 같아. 처음 알았어_
    
-   개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있기 때문에 → 항상 조심하는 것이 좋다.
    
    -   가장 큰 오용 중 하나 : 협력업체 웹 사이트가 사용자를 추적하려고 지속 쿠키를 사용하는 것.
        
        지속 쿠키를 ip 주소와 referer 헤더에 있는 정보와 함께 사용하면 → (마케팅) 회사들은 사용자의 프로필과 사용 패턴에 대해 꽤 정확한 데이터를 수집할 수 있다.
        
    -   제공하는 개인정보를 누가 받는지 명확히 알고, 사이트의 개인정보 정책에 유의한다면, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.

#   12장 기본 인증

-   사용자를 확인하는 기초적인 체계를 다룬다.

-   어떻게 http 인증이 데이터베이스와 동작하는지

-   웹사이트에 있는 개인의 프로필이나 개인이 작성한 문서는 해당 소유자의 동의 없이는 권한이 없는 사용자가 볼 수 없어야 한다. 또, 기업에 있는 민감한 전략 문서는 조직 내에서 권한이 없는 임직원이 볼 수 없게 해야 한다.

	이러기 위해선 서버가 사용자가 누구인지 식별할 수 있어야 한다. 서버가 사용자가 누구인지 알면, 그 사용자가 어떤 작업이나 리소스에 접근할 수 있는지 결정할 수 있다.

-   보통 사용자 이름과 비번을 입력해서 인증한다.

-   http는 자체적인 인증 관련 기능을 제공한다.

##   12.1 인증

-   http에 있는 2가지 공식적인 인증 프로토콜
    -   기본 인증
    -   다이제스트 인증

###   12.1.1 http의 인증요구/응답 프레임워크
-   http는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.
    
-   http 인증 모델
    
-   웹 애플리케이션이 http 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 (현재 사용자가 누구인지를 알 수 있게 비번과 같은 개인 정보를 요구하는) 인증 요구로 응답할 수 있다.
    
    -   사용자가 다시 요청을 보낼 땐, 인증 정보(사용자 이름, 비번)를 첨부해야 한다.
        -   인증 정보가
            -   맞지 않으면 → 서버는 클라이언트에 다시 인증 요구를 보내거나 에러를 낼 수 있다.
            -   맞으면 → 요청은 문제 없이 처리가 완료된다.

###   12.1.2 인증 프로토콜과 헤더
-   http는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해 → 다른 인증 프로토콜에 맞춰 확장할 수 있는 프레임워크를 제공한다.
    
-   인증 프로토콜은 http 인증 헤더에 작성돼 있다.
    
-   인증 단계

###   12.1.3 보안 영역
-   http가 어떻게 각 리소스마다 다른 접근 조건을 다루는지 보자
    
-   웹 서버는 기밀 문서를 보안 영역 realm 그룹으로 나눈다. 보안 영역은 저마다 다른 사용자 권한을 요구한다.
    
    ex) 웹 서버가 보안 영역을 회사의 재정 정보, 개인의 가족 문서 2개 가진다고 하자. 회사의 ceo는 판매 예측 자료에 접근할 수 있지만, 가족 방학 사진에 접근할 권한을 주지는 않을 것이다.
        
##   12.2 기본 인증

-   기본 인증은 잘 알려진 http 인증 규약이다.
    
-   거의 모든 주요 클라이언트와 서버에 기본 인증이 구현돼 있다.
    
-   기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비번을 요구할 수 있다. 서버는 200 대신 401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 www-authenticate에 작성해서 응답하여 → 인증 요구를 시작한다.
    
-   인증 정보를 포함하여 요청하라는 응답을 받은 브라우저는, 사용자에게 계정과 비번을 입력할 수 있는 UI를 연다.
    
    -   계정과 비번은 사용자가 해당 영역에 접근 권한이 있는지 검사하는 데 사용된다.
    -   브라우저는 사용자가 입력한 사용자 이름과 비번을 authorization 요청 헤더 안에 암호화해서 서버로 다시 보낸다.

    
###   12.2.2 base-64 사용자 이름/비번 인코딩

-   ex) 사용자 이름과 비번으로 기본 authorization 헤더 생성
    
-   base-64 인코딩
    
    -   바이너리, 텍스트, 국제 문자(ex. 유니코드)를 ASCII 문자(전송 가능한 문자인 알파벳, 숫자)으로 변환한다
    -   원본 문자열이 변질되지 않고 전송된다.
    -   국제 문자나 http 헤더에서 사용할 수 없는 문자(큰따옴표, 콜론, 캐리지 리턴)을 포함한 사용자 이름이나 비번을 보내야 할 때 유용할 수 있다.
    -   어렵지 않게 사용자 이름과 비번 문자를 섞을 수 있기 때문에 → 서버나 네트워크를 관리하면서 뜻하지 않게 사용자 이름과 비번이 노출되는 문제를 예방하는 데 도움이 된다.
-   보안에 대한 주의점
    
    -   Base64는 **암호화가 아님** → 단순히 인코딩일 뿐, 복호화가 너무 쉬움.
        
    -   ex) Authorization 헤더에서 `Basic YWRtaW46cGFzc3dvcmQ=`는 ID:PW를 그대로 노출한 것일 수 있음.
        
    -   cf) 인코딩 vs 암호화
        
        ## 인코딩
        
        **목적**: 데이터 형식 변환 및 호환성
        
        -   문자 집합 변환 (UTF-8, ASCII 등)
        -   전송 형식 맞춤 (Base64, URL 인코딩)
        -   데이터 표현 방식 변경
        
        인코딩이 데이터 형식을 변환하는 이유는 **서로 다른 시스템 간의 호환성과 안전한 전송**을 위해서입니다.
        
        ## 시스템 간 호환성 문제
        
        컴퓨터마다 문자를 표현하는 방식이 달랐습니다.
        
        ```
        영어: ASCII (7비트)
        한글: EUC-KR, CP949
        ```
        
		한글로 작성한 파일을 다른 나라 컴퓨터에서 열면 깨져 보이는 문제가 흔했습니다.
        
        ## 암호화
        
        **목적**: 데이터 보안 및 기밀성 보장
        
        -   권한 없는 접근 방지
        -   데이터 보호
###   12.2.3 프락시 인증

-   중개 프락시를 통해 인증할 수도 있다
    
-   어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시를 거치게 하여 사용자를 인증한다. 프락시에서 접근 정책을 중앙 관리할 수 있기 때문에 → 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해 프락시 서버를 사용하면 좋다.
    
    첫 번재 단계 : 프락시 인증으로 사용자를 식별하는 것
    
-   프락시 인증은 웹 서버의 인증과 헤더, 상태 코드만 다르고 절차는 같다.
    
-   웹 서버와 프락시 인증에서 쓰이는 상태 코드와 헤더들의 대조표
    
##   12.3 기본 인증의 보안 결함

-   기본 인증은 사용자 이름과 비번을 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다.
    
    인코딩한 비번은 누구나 읽기 쉽게 어렵지 않은 일반 문자열로 보낸다. base-64로 인코딩된 사용자 이름과 비번은 인코딩 절차를 반대로 수행해서 어렵지 않게 디코딩할 수 있다. base-64로 인코딩된 비번은 사실상 비번을 그대로 보내는 것과 다름 없다.
    
    누군가가 악의적으로 기본 인증으로 보낸 사용자 이름과 비번을 가로챌 수 있으므로 → 모든 http 트랜잭션을 ssl 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋다.
    
    -   프론트엔드 개발자가 HTTPS를 적용하거나 사용하는 방법
        
        ### 1. **HTTPS로 배포된 도메인에서만 서비스 실행**
        
        -   배포 환경에서는 프론트엔드 애플리케이션이 반드시 HTTPS로 접근되도록 설정해야 합니다.
        -   예: Netlify, Vercel, Cloudflare Pages, GitHub Pages 등 대부분의 정적 호스팅 서비스는 HTTPS를 자동 적용해줍니다.
        
        ----------
        
        ### 2. **백엔드 서버 또는 프록시 서버가 HTTPS를 제공하는지 확인**
        
        -   프론트엔드에서 호출하는 API 주소가 `http://`이면 **Mixed Content 오류** 발생 → 반드시 `https://`로 바꿔야 함.
        -   `axios` 또는 `fetch`로 API 호출할 때에도 HTTPS 사용 여부 확인:
        
	        ```
	        // 잘못된 예
	        fetch("<http://api.example.com/user>")
	        
	        // 올바른 예
	        fetch("<https://api.example.com/user>")
	        ```
        
        ----------
        
        ### 3. **서비스 워커(Service Worker) 또는 PWA 사용 시 HTTPS 필수**
        
        -   서비스 워커는 HTTPS 환경에서만 동작합니다. 따라서 PWA를 만들 경우 프론트 개발자가 HTTPS 배포 환경을 고려해야 합니다.
        
        ----------
        
        ### 4. **리디렉션 또는 강제 HTTPS 설정 요청**
        
        -   Cloudflare, Nginx, Netlify 등에서 HTTP 요청을 HTTPS로 자동 리디렉션하게 설정 가능
        -   프론트 개발자는 다음 설정을 인프라/백엔드 담당자에게 요청하거나 직접 설정할 수 있습니다:
        
	        ```
	        # HTTP를 HTTPS로 리디렉션
	        server {
	          listen 80;
	          server_name example.com;
	          return 301 https://$host$request_uri;
	        }
	        ```
        
        ----------
        
        ### 5. **HSTS (HTTP Strict Transport Security) 설정 요청**
        
        -   브라우저가 항상 HTTPS로만 접속하도록 유도하는 응답 헤더
        
	        ```
	        Strict-Transport-Security: max-age=63072000; includeSubDomains; preload
	        ```
        
        > 프론트 개발자는 이 헤더가 적용되었는지 확인하고, 필요 시 서버 설정을 요청할 수 있습니다.
        
-   기본 인증은 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다.
    
    보안 비번이 디코딩하기에 더 복잡한 방식으로 인코딩돼 있다고 하더라도, 여전히 누군가는 사용자 이름과 비번을 캡처한 다음, 그것을 그대로 원 서버에 보내서 인증에 성공하고, 서버에 접근할 수 있다.
    
-   비번을 요구하는 수많은 사이트에 지쳐버린 수많은 사용자는 그 모든 사이트에 같은 아이디와 비번을 사용한다.
    
    누군가는 무료 인터넷 이메일 같은 사이트에서 사용자 이름과 비번을 그대로 캡처하고, 동일한 사용자 이름과 비번으로 중요한 온라인 은행 사이트에 접근할 수도 있다.
    
-   메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않는다.
    
-   기본 인증은 가짜 서버의 위장에 취약하다.
    
    만약 사용자가 가짜 서버나 가짜 게이트에 연결돼 있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결돼 있다고 믿으면, 공격자는 사용자에게 비번을 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것이다.
    

----------

기본 인증은 사용자 이름과 비번을 base-64로 인코딩 합니다. base-64 인코딩은 인코딩 과정을 반대로 수행하면 디코딩할 수 있습니다. 때문에 기본 인증으로 전송한 사용자 이름과 비번을 공격자가 어렵지 않게 알아낼 수 있는 보안 문제가 있습니다. → 따라서 사용자 정보를 안전하게 전송하기 위해 HTTPS를 사용해 데이터를 암호화해야합니다.

----------

기본 인증

-   일반적인 환경에서 개인화나 접근을 제어하는데 편리
    
-   다른 사람들이 보지 않기를 원하기는 하지만, 보더라도 치명적이지 않은 경우에는 유용하다.
    
-   호기심 많은 사용자가 우연이나 사고로 정보에 접근해서 보는 것을 예방하는 데 사용한다.
    
-   ex) 회사는 한정판으로 우선 판매할 제품의 계획서와 같은 중요한 문서는 비번으로 보호할 수 있다. 기본 인증은 외부 업체가 해당 데이터에 접근하는 것을 상당히 불편하게 만든다.
    
    매 요청마다 인증 정보 필요
    
    -   기본 인증은 요청마다 `Authorization: Basic <base64 encoded id:password>` 헤더를 반드시 포함해야 해요.
    -   인증 정보를 누락하면 무조건 401 Unauthorized가 반환되고, 접근 자체가 막힘.
    
    ➡️ 자동화되지 않은 외부에서는 매우 번거롭게 느껴짐.
    
-   기본 인증은 사용자 이름과 비번을 공격자로부터 숨기려고 암호화된 데이터 전송(ex. SSL)과 연계해서 사용할 수 있다. - 널리 사용하는 기술임

#   14장 보안 http

-   인터넷 암호화 기법에 대한 개요, 디지털 서명, 보안 소켓 계층 secure sockets layer ssl에 대해

-   디지털 암호화를 이용해 도청이나 위조로부터 http 트랜잭션을 안전하게 보호하는 더 복잡하고 적극적인 기술 제시

##   14.1 http를 안전하게 만들기

중요한 트랜잭션을 위해선, http와 디지털 암호화 기술을 결합해야 한다.


##   14.2 디지털 암호학

-   Cryptography
    
-   브라우저에서 HTTPS를 통해 서버와 통신할 때 TLS는 암호학을 기반으로 동작.
    
    -   ex) `fetch` 요청을 할 때 HTTPS는 자동으로 암호화되어 전송됨.
-   암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘 / 메시지를 인코딩하는 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법
    
-   키 : 암호의 동작을 변경하는 숫자로 된 매개변수
    
-   대칭키 암호 체계 : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
    
-   비대칭키 암호 체계 : 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
    
###   14.2.1 비밀 코드의 기술과 과학

-   암호법은 메시지 인코딩과 디코딩에 대한 기술이자 과학이다.
-   암호법은 단순히 공격자가 볼 수 없도록 메시지를 암호화하는 것뿐 아니라, 메시지의 변조를 방지하기 위해 사용할 수도 있다.
-   암호법은 수표에 손으로 쓴 서명과 같이 누군가가 정말로 어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용될 수 있다.

###   14.2.2 암호 cipher

-   비밀 코드임
    
-   암호법은 암호에 기반한다.
    
-   인코딩되기 전의 원본 메시지는 흔히 텍스트 / 평문이라고 부른다.
    
-   암호가 적용되어 코딩된 메시지는 보통 암호문이라고 부른다.
    
-   암호는 비밀 메시지를 만들기 위해 사용돼 왔다.
    
-   율리우스 카이사르는 rot3 암호를 사용했다.
    
    -   rot3 rotate by 3 세 글자 순환 암호 : 메시지의 각 글자를 해당 글자의 알파벳 순서상 세 번 뒤의 글자로 교체
    -   ex) a → d
    -   메시지 ‘me’에 rot3를 적용하면 암호문 ‘ph’으로 인코딩된다. 이 암호문은 코딩을 반대로 적용해서 모든 글자를 알파벳상에서 -3 글자씩 회전 시키면 원본 평문 메시지로 해독된다.

###   14.2.3 암호 기계

암호는 상대적으로 간단한 알고리즘으로 시작했는데, 암호가 간단하기 때문에, 사람들은 암호화 작업을 연필과 종이와 암호첩 code book으로 수행할 수 있었다. 그러나 똑똑한 사람들이라면 꽤 간단하게 암호를 푸는 것도 가능했다

기술이 진보하면서, 사람들은 보다 복잡한 암호로 메시지를 빠르고 정확하게 인코딩하고 디코딩하는 기계를 만들기 시작했다.

암호 기계는 암호를 풀기 어렵게 하기 위해, 단순히 회전을 하는 대신, 글자들을 대체하고, 그 순서를 바꿨으며, 메시지를 자르고 토막냈다.

###   14.2.4 키가 있는 암호

-   코드 알고리즘과 기계가 공격자의 손에 들어갈 수 있기 때문에, 대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 다이얼이 달려있다. 누군가 기계를 훔치더라도 올바른 다이얼 설정(키 값) 없이는 디코더가 바르게 동작하지 않을 것이다. 바르게 디코딩하려면 올바른 키를 암호 기계에 입력해야 한다.
    
-   암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다. 이 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 / 사용하기 때문에 → 제각각 다르게 동작한다.
    
-   오늘날 거의 대부분의 암호 알고리즘은 키를 사용한다.
    
-   같은 입력 메시지가 같은 인코딩 기계를 통과하더라도 키의 값에 따라 다른 출력을 생성한다.
    
-   ex) N번 회전 암호
    
    -   n의 값은 키에 의해 달라진다.

###   14.2.5 디지털 암호

-   디지털 계산이 나타남으로써, 2가지 주요한 발전이 있었다.
    -   복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
    -   매우 큰 키를 지원하는 것이 가능해졌다. 키가 길수록 인코딩의 많은 조합이 가능해지고, 무작위로 추측한 키에 의한 크래킹이 어려워진다.
-   기계 장치의 물리적인 키나 다이얼 설정과는 달리, 디지털 키는 그냥 숫자다.
-   디지털 키 값 : 인코딩과 디코딩 알고리즘에 대한 입력값
-   코딩 알고리즘 : 데이터 덩어리를 받아서 알고리즘과 키의 값에 근거해서 인코딩하거나 디코딩하는 함수

-   평문 메시지 P, 인코딩 함수 / 인코더 E, 디지털 인코딩 키 e가 주어지면 암호문 C를 만들 수 있다.
-   암호문 C를 디코딩 함수 D와 디코딩 키 d를 사용해서 원래의 평문 P로 디코딩할 수 있다.
-   디코딩과 인코딩 함수는 서로의 역이다.
-   P의 인코딩에 대한 디코딩은 원래의 메시지 P다.

##   14.3 대칭키 암호법

-   많은 디지털 암호 알고리즘은 대칭키 암호라고 불린다. ← 인코딩을 할 때 사용하는 키가 디코딩을 할 때와 같기 때문. e = d
    
-   대칭키 암호에서 발송자와 수신자 모두 통신을 위해 똑같은 비밀 키 e를 공유해야한다.
    
    -   발송자는 공유된 비밀 키를 메시지를 암호화하고 (그 결과인) 암호문을 수신자에게 발송하기 위해 사용한다.
    -   수신자는 암호문을 받은 뒤 같은 키를 원래의 평문으로 복원하기 위해 사용한다.
-   잘 알려진 대칭키 암호 알고리즘 : des, triple-des, rc2, rc4
    
###   14.3.1 키 길이와 열거 공격 enumeration attack

-   비밀 키는 누설되면 안된다. 대부분의 경우, 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀이다
    
-   열거 공격 : 무차별로 모든 키 값을 대입해보는 공격
    
-   좋은 암호 알고리즘은 공격자가 코드를 크래킹하려면 이 우주에 존재하는 모든 가능한 키 값을 시도해보는 것 외에 다른 방법이 없게 만든다.
    
    _암호를 해독하려는걸 크래킹이라고 표현하는구나_
    
-   만약 가능한 키 값이 몇 가지 밖에 없으면 악당은 무차별 대입으로 모든 값을 시도하고 결국 암호를 풀 것이다. 그러나 가능한 키 값이 아주 많다면 → 악당은 암호를 풀 수 있는 값 하나를 찾기 위해 수일 ~ 우주의 수명만큼의 시간을 들여야 할것이다.
    
-   가능한 키 값의 개수는 키가 몇 비트이며, 얼마나 많은 키가 유효한지에 달려있다.
    
    대칭키 암호에서는 보통 모든 키 값이 유효하다.
    
    ex) 8비트 키라면 256가지 값이 가능하다
    
-   평범한 대칭키 암호에서, 40비트 키는 작고 중요하지 않은 업무에는 충분하다고 할 수 있다. 그러나 초당 수십억 번의 계산이 가능한 오늘날의 빠른 워크스테이션에겐 쉽게 깨질 수 있다.
    
-   128비트 키를 사용한 대칭키 암호는 매우 강렬한 것으로 간주된다.
    
-   미국 정부는 미국 국가안보국 NSA가 깨뜨릴 수 없는 암호문을 적대적인 조직이 만들어 낼 가능성을 차단하기 위해 긴 키를 사용하는 암호화 소프트웨어의 수출을 통제한다.
    
-   암호에 기반한 보안에 있어 키의 길이는 중요하다.
    
###   14.3.2 공유키 발급하기

-   대칭키 암호의 단점 중 하나 : 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 점
    
    발송자와 수신지 모두 비밀 키를 생성하고, 그것을 기억해야한다.
    
-   ex) a, b, c가 죠의 하드웨어 j와 은밀한 대화를 원한다고 해보자.
    
    a, b, c는 각각 j와의 비밀 키를 발급해야한다. a는 k-aj, b는 k-bj, c는 k-cj
    
    관리해야 하는 사람 입장에서 이것은 지옥이다.
        
##   14.4 공개키 암호법

-   : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
    
-   공개키 암호 방식은
    
    -   두 개의 **비대칭** 키를 사용한다.
    -   인코딩과 디코딩에 다른 키를 사용하는 비대칭이다
-   하나는 호스트의 메시지를 인코딩하기 위한 것이며, 다른 하나는 그 호스트의 메시지를 디코딩하기 위한 것.
    
-   인코딩 키는 모두를 위해 공개돼 있지만, 호스트만이 개인 디코딩 키를 알고 있다.
    
    _그러면 인코딩하는 의미가 있나?_
    
-   키의 분리는
    
    -   메시지의 인코딩은 누구나 할 수 있도록 해주고
    -   메시지를 디코딩할 수 있는 권한은 소유자에게만 부여한다
    -   노드가 서버로 메시지를 안전하게 전송하는 것을 더 쉽게 해준다. ← 서버의 공개 키만 있으면 되기 때문에
    -   보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다.
-   노드 X는 자신의 인코딩 키 ex를 공개적으로 배포할 수 있다. 그럼 노드 X에게 메시지를 보내고자 하는 누구나 똑같은 공개키를 사용할 수 있다. 각 호스트마다 누구나 사용할 수 있는 인코딩 키가 할당돼 있기 때문에 → 공개키 암호 방식은 대칭 키의 쌍이 n^2으로 폭발적으로 증가하는 것을 피할 수 있다.
    
    모든 사람이 x에게 보내는 메시지를 같은 키로 인코딩할 수 있지만, x를 제외한 누구도 그 메시지를 디코딩할 수 없다. 오직 x만이 디코딩 개인 키 dx를 갖고 있기 때문이다.
    
-   **공개키**로 암호화하고, **개인키**로 복호화.
    
-   키를 공개해도 안전하다는 점이 핵심.
    
-   HTTPS에서 TLS handshake 시 사용됨.
    
    프론트엔드는 인증서 기반 공개키 암호화로 서버와 보안 연결을 맺음.
    
###   14.4.1 RSA

-   mit에서 발명되고 있음
    
-   공개키, 평문의 일부, 공개키로 평문을 인코딩해서 얻은 평문에 대한 암호문, RSA 구현 소스 코드까지 주어져도 암호를 해독해서 해당하는 개인 키를 찾아내는 것은 어렵다고 함
    
    _신기하당 많이 빡센가 보네_
        
-   **대칭키 암호법 🆚 공개키 암호법**

	대칭키 암호법

	-   인코딩을 할 때 사용하는 키와 디코딩을 할 때 사용하는 키가 같습니다.
	-   인코딩 디코딩 속도가 빨라서 대용량 파일을 전송할때 적합합니다.

	공개키 암호법

	-   인코딩과 디코딩에 다른 키를 사용합니다.
	-   인코딩 키는 모두에게 공개돼있는 공개키이고, 디코딩 키는 개인키로 사용자만 가집니다. 즉, 메시지의 인코딩은 누구나할 수 있고, 디코딩은 소유자만 할 수 있습니다.
	-   인터넷에서 처음 만나는 사용자들 사이의 통신과 같이 사전에 키를 공유할 수 없는 상황에서 사용합니다.

##   14.5 디지털 서명 digital signing

-   : 메시지가 위조 / 변조되지 않았음을 입증하는, 메시지에 붙어 있는 체크섬
    
-   개인키로 서명 → 공개키로 검증 가능
    
    *공개 키 암호랑 반대네*
    
-   데이터가 위변조되지 않았고, 서명자의 것이라는 인증 기능
    
-   JWT의 **서명 부분**은 디지털 서명의 개념을 사용
    
    -   마지막 파트가 서명 부분
-   암호 체계는 메시지가 위조되지 않았음을 증명하기 위해서 메시지에 서명을 하도록 하는 데에 이용될 수 있다.
    
-   인터넷 보안 인증서에서 중요하다
    
-   디지털 서명은 보통 비대칭 공개키에 의해 생성된다.
    
-   개인 키는 오직 소유자 / 저자만이 알고 있기 때문에 → 일종의 지문처럼 사용된다
    
-   ex) 노드 A가 노드 B에게 메시지를 보내고, 그것을 서명
    
    -   한번 서명이 계산되면, 노드 A는 그것을 메시지의 끝에 덧붙이고, 메시지와 그에 대한 서명 둘 다를 노드 B에게 전송한다.
    -   메시지를 받은 노드 B가 만약 그 메시지를 쓴 것이 정말로 노드 A이고 동시에 위조되지도 않았다는 것을 확인하길 원한다면, 노드 B는 서명을 검사할 수 있다.
    
-   서명은 암호 체크섬이다
    
    -   디지털 서명 장점
        -   서명은 메시지를 작성한 저자가 누군지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만 이 체크섬을 계산할 수 있다.
            
        -   서명은 메시지 위조를 방지한다.
            
            만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다. 침입자는 위조된 메시지에 대한 올바를 체크섬을 날조할 수 없을 것이다.
            
##   14.6 디지털 인증서 Digital Certificate

-   : 신뢰할 만한 기관 / 조직에 의해 서명되고 검증된 / 보증된 신원(사용자 / 회사) 확인 정보 / 공개키가 진짜인지 공인된 기관(CA)이 보증하는 전자 문서 / 웹사이트나 서버의 신원을 증명하는 전자 문서
    
-   흔히 certs라고 불린다.
    
-   PKI(Public Key Infrastructure)의 핵심 구성 요소
    
-   브라우저는 서버의 TLS 인증서를 자동 검증함
    
    사용자는 HTTPS가 안전함을 이 인증서를 통해 보장받음
    
-   인증서가 유효하지 않으면 브라우저는 보안 경고를 띄우고, 요청을 차단
    
-   JavaScript에서 `fetch()` API나 XMLHttpRequest를 사용할 때, 인증서가 만료되었거나 유효하지 않으면 네트워크 에러가 발생합니다.
    
    -   개발 단계에서 자주 마주치는 문제(인데, 특히 로컬 개발 환경에서 자체 서명된 인증서를 사용할 때 주의해야 합니다.)
-   HTTPS 연결을 가능하게 함
    
    -   디지털 인증서가 있어야 HTTPS 연결이 가능합니다.
    -   HTTP에서 HTTPS로 리다이렉트하는 로직을 구현할 때, 인증서가 제대로 설정되어 있는지 확인해야 합니다.
    -   브라우저 주소창의 자물쇠 아이콘이 바로 유효한 인증서가 있다는 의미
    -   인증서와 함께 CSP(Content Security Policy) 헤더를 설정해서 보안을 강화할 수 있습니다. `upgrade-insecure-requests` 지시어를 사용하면 HTTP 요청을 자동으로 HTTPS로 업그레이드할 수 있어요.
    -   HTTPS 사이트에서 HTTP 리소스(이미지, 스크립트, CSS 등)를 로드하려고 하면 브라우저가 차단합니다.
-   데이터를 암호화한다
    
-   웹사이트를 인증한다
    
-   로컬 개발 환경`localhost`에서 HTTPS를 테스트하려면 개발용 인증서가 필요합니다. `mkcert` 같은 도구로 로컬 인증서를 생성하거나, Vite, Webpack Dev Server 같은 도구에서 제공하는 HTTPS 옵션을 활용할 수 있습니다.
    
-   외부 API와 통신할 때 해당 API 서버의 인증서 상태를 확인해야 합니다. 만료된 인증서나 잘못 설정된 인증서 때문에 API 호출이 실패하는 경우가 있거든요.
    
-   여러 서브도메인을 사용하는 경우 와일드카드 인증서(`*.example.com`)나 SAN(Subject Alternative Name) 인증서가 필요합니다. CDN을 사용할 때도 CDN 제공업체에서 제공하는 인증서 설정을 확인해야 합니다.
    
-   Security 탭에서 현재 페이지의 인증서 정보를 확인할 수 있습니다. 인증서 발급 기관, 유효 기간, 도메인 정보 등을 볼 수 있어서 디버깅할 때 유용해요. Network 탭에서도 HTTPS 요청의 보안 상태를 확인할 수 있습니다.
    
###   14.6.1 인증서의 내부

-   기본적인 디지털 인증서는 보통 아래의 것들을 포함한다
    -   대상의 이름(사람, 서버, 조직 등)
    -   유효 기간
    -   인증서 발급자(누가 이 인증서를 보증하는가)
    -   인증서 발급자의 디지털 서명

###   14.6.3 서버 인증을 위해 인증서 사용하기

-   사용자가 https를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.
    
    -   이때 서버가 인증서를 갖고 있지 않으면, 보안 커넥션은 실패한다.
    -   브라우저가 인증서를 받으면, 서명 기관을 검사한다.
        -   그 기관이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며(브라우저들은 여러 서명 기관의 인증서가 미리 설치된 채로 출시된다), 브라우저는 그 서명을 검증할 수 있다.
        -   모르는 서명 기관이라면 → 브라우저는 그 서명 기관을 신뢰해야 할지 확신할 수 없으므로, 대개 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여준다. 서명 기관은 사용자가 다니는 회사의 it 부서이거나 소프트웨어 개발사일 수도 있다.
-   서버 인증서는 아래를 포함한 필드를 가진다
    
    -   웹 사이트의 이름과 호스트 명
    -   웹 사이트의 공개키
    -   서명 기관의 이름
    -   서명 기관의 서명
-   디지털 서명을 이용해 인증서의 무결성 검증하는 방법 / 서명이 진짜인지 검증
        
##   14.7 https의 세부 사항

### https

-   http를 안전하게 만드는 방식 / http의 보안 버전 중에서 가장 인기 있음 / 유명함
    
-   넷스케이프에서 만듦
    
-   모든 주류 브라우저와 서버에서 지원함 / 주류 상용 브라우저와 서버에 구현돼 있음
    
-   웹페이지에 http가 아닌 https로 접근하면, url이 [http://가](http://xn--o39a) 아닌 [https://로](https://xn--2o2b) 시작한다.
    
-   https를 사용하면, 모든 http 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.
    
-   https는 http의 하부에 (전송 레벨 암호) 보안 계층을 제공함으로써 동작한다. / https는 보안 전송 계층을 통해 전송되는 http다.
    
    이 보안 계층은 SSL / TSL을 이용해서 구현된다.
    
    SSL, TSL은 매우 비슷해서 책에선 둘다를 표현하는 용어로 (엄밀하진 않지만) SSL을 사용할거다
    
    암호화되지 않은 http 메시지를 tcp를 통해 인터넷 곳곳으로 보내는 대신에(a), https는 메시지를 tcp로 보내기 전에 먼저 메시지를 암호화하는 보안 계층으로 보낸다.
    
    ssl 보안 계층
    
-   어려운 인코딩 및 디코딩 작업은 대부분 ssl 라이브러리 안에서 일어나기 때문에, 보안 http를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다. 대부분의 경우, tcp 입력/출력 호출을 ssl 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 된다.
    
-   https는 http 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것 → https를 매우 안전한 동시에 매우 유연하고 관리하기 쉽게 만든다
    
-   http 🆚 https
    
    http는 웹에서 클라이언트와 서버가 데이터를 주고받기 위한 프로토콜입니다.
    
    https는 http의 보안성을 높인 것으로, 요청 및 응답 데이터를 전송하기 전에 SSL/TLS 프로토콜을 사용하여 암호화한다. → 데이터를 안전하게 전송할 수 있습니다.
    
    HTTP의 포트 번호는 80, HTTPS는 443입니다. URL은 각각 http:// 와 [https://로](https://xn--2o2b) 시작합니다.
    
    이러한 특성에 따라 https는 민감한 정보를 주고받아야 하는 웹사이트와 로그인 페이지에서 사용됩니다.
    
###   14.7.2 https 스킴

-   오늘날 보안 http는 선택적이다. 따라서 → 웹 서버로의 요청을 만들 때, 우리는 웹 서버에게 http의 보안 프로토콜 버전을 사용한다고 말해야한다. 방법 : url의 스킴
    
-   (보안이 없는) 일반적인 http의 url 스킴 접두사 : http
    
-   (보안이 되는) https의 url 스킴 접두사 : https
    
-   (웹 브라우저 등의) 클라이언트는 웹 리소스에 대한 트랜잭션을 하라고 요청받으면 url의 스킴을 검사한다. url의 스킴이
    
    -   http이면 → 클라이언트는 서버에 80번 포트로 연결하고 / tcp 커넥션을 열고, 평범한 http 명령을 전송한다. (a)
    -   https이면 → 클라이언트는 서버에 443 포트로 연결하고, 핸드셰이크를 하고, 암호화된 http 명령을 전송한다. (b)
    
-   ssl 트래픽은 바이너리 프로토콜이기 때문에, http와는 완전히 다르다. 이 트래픽은 다른 포트(ssl은 보통 443 포트를 통해 전달된다)로 전달된다.
    
    만약 ssl과 http 트래픽 모두가 80번 포트로 도착하면, 대부분의 웹브라우저는 바이너리 ssl 트래픽을 잘못된 http로 해석하고, 커넥션을 닫을 것이다.
    
    _ssl이랑 http 트래픽이 다 80번 포트로 도착할 수도 있구나_
    
###   14.7.3 보안 전송 셋업

-   http에서 클라이언트는 웹 서버의 80번 포트로 tcp 커넥션을 열고, 요청 메시지를 보내고, 응답 메시지를 받고, 커넥션을 닫는다. (a)
-   https에서 클라이언트는 웹 서버의 443 포트로 연결한다. tcp 커넥션을 열고 나서 → ssl 핸드셰이크를 하고 → 핸드셰이크가 완료되면 ssl 초기화는 완료되고 → 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다. 이 메시지는 tcp로 보내지기 전에 암호화된다.

###   14.7.4 ssl 핸드셰이크

-   클라이언트는 서버와 바이너리 포맷으로 된 몇몇 ssl 보안 매개변수와 교환 키를 교환 / 협상하면서 핸드셰이크를 한다.
    
-   암호화된 http 메시지 / 데이터를 보내기 전에, 클라이언트와 서버는 ssl 핸드셰이크를 해야한다.
    
-   핸드셰이크에서 일어나는 일
    
    -   프로토콜 버전 번호 교환
    -   양쪽이 알고 있는 암호 선택
    -   양쪽의 신원을 인증
    -   채널을 암호화하기 위한 임시 세션 키 생성
-   ssl은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고 받는다
    
-   ssl 핸드셰이크의 핵심 / 일반적인 개념
    
    -   ssl 핸드셰이크를 단순화한 버전임
        
        ssl이 어떻게 사용되는가에 따라 핸드셰이크는 더 복잡해질 수 있음
        
    
    1.  **클라이언트가 서버에게 지원하는 암호화 방식 목록과 함께 연결 요청**을 보냅니다.
        
    2.  **서버가 선택한 암호화 방식과 함께 응답**합니다
        
    3.  **서버가 자신의 인증서를 클라이언트에게 전송**합니다
        
    4.  클라이언트가 비밀 정보를 보낸다. 클라이언트와 서버는 키를 만든다.
        
        -   비밀키를 직접 주고받지 않아도, 같은 비밀값(세션 키)을 만들어낼 수 있는 수학적 방법
            
        -   **(Ephemeral) Diffie-Hellman 방식 (DHE / ECDHE)** ← 현대 TLS에서 주로 사용
            
            -   *클라이언트와 서버가 각자 임시 키쌍(공개키/개인키)**을 생성하고,
            -   서로의 **공개키를 주고받아 같은 세션 키를 계산**함
            -   세션 키는 **절대 네트워크로 직접 전달되지 않음**
            
            > 💡 이 방식은 "세션 키를 공유하지 않고도 공유할 수 있게" 해주는 수학적 기법입니다.
            
    5.  클라이언트와 서버는 서로에게 암호화를 시작한다고 서로에게 말해준다.
        
        -   클라이언트 → 서버: `Change Cipher Spec` 메시지 + 암호화된 `Finished` 메시지
        -   서버 → 클라이언트: `Change Cipher Spec` 메시지 + 암호화된 `Finished` 메시지
    6.  이후부터는 실제 데이터(예: HTTP 요청/응답)가 **암호화되어 전송**됩니다.
        
    
    -   간략한 과정
        1.  클라이언트가 서버에게 지원하는 암호화 방식 목록과 함께 연결 요청을 보냅니다
        2.  서버는 응답에 선택한 암호화 방식과 자신의 인증서를 포함해 클라이언트에게 전송합니다
        3.  클라이언트와 서버는 키를 생성합니다
        4.  암호화를 시작한다고 서로에게 알립니다
        5.  이후부터는 데이터가 암호화되어 전송됩니다

###   14.7.5 서버 인증서

-   ssl은 서버 인증서를 클라이언트로 나르고, 다시 클라이언트 인증서를 서버로 나르는 상호 인증을 지원한다.
    
    -   오늘날, 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다. 대부분의 사용자는 개인 클라이언트 인증서를 가지지 않는다. 웹 서버는 클라이언트 인증서를 요구할 수 있지만, 실제론 좀처럼 일어나지 않는 일이다.
-   https 트랜잭션은 항상 서버 인증서를 요구한다.
    
    (웹 서버에 신용카드 정보를 보내는 것과 같은) 보안 트랜잭션을 할때, 그는 대화 중인 조직이 그와 대화하고 있다고 생각한 그 조직이 맞는지 알고 싶을 것이다.
    
    서버 인증서는 사용자가 그 서버를 얼마나 신뢰할 수 있는지를 정하는 것을 도와줄 것이다.
    
-   서버 인증서는 x.509 v3 인증서에서 파생됐다.
    
    -   조직의 이름, 주소, 서버 dns 도메인 이름 등을 보여준다.
-   사용자와 사용자의 클라이언트 소프트웨어는 모든 것이 믿을 만한지 확인하기 위해 인증서를 검증할 수 있다.
    
###   14.7.6 사이트 인증서 검사

-   ssl 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 웹브라우저들 대부분은 인증서에 대해 간단하게 기본 검사를 한다. 그리고 그 결과와 더 철저하게 검사할 수 있는 방법을 사용자에게 알려준다.
    
-   넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹브라우저의 검사 기법의 기초를 구축했다.
    
    이 알고리즘의 단계 :
    
    -   날짜 검사
        
        -   브라우저는 인증서의 유효함을 확인하기 위해 → 인증서의 시작 및 종료일을 검사한다.
            -   인증서가 만료됐거나 아직 활성화되지 않았다면 → 인증서 검사는 실패하고, 브라우저는 에러를 보여준다.
    -   서명자 신뢰도 검사
        
        -   모든 인증서는 서버를 보증하는 어떤 인증 기관(CA certificate authority)에 의해 서명돼 있다.
        -   여러 수준의 인증서가 있다.
        -   ex) 전자상거래 서버 인증서를 발급받고자 한다면, 사업체로서의 법인에 대한 법적 증명을 제시해야 한다.
        -   누구나 인증서를 생성할 수 있지만, 몇몇 CA는 인증서 지원자의 신원 및 사업의 선량함을 입증하는 절차를 요구한다. 이러한 이유로 → 브라우저는 신뢰할 만한 서명 기관의 목록을 포함한 채로 배포된다.
            -   만약 브라우저가 알려져 있지 않은(그리고 악의적일 가능성이 있는) 인증기관으로부터 서명된 인증서를 받았다면, 브라우저는 보통 경고를 보여준다.
                
            -   브라우저는 신뢰할만한 CA가 ‘간접적으로’ 서명한 인증서를 받아들이는 것을 선택할 수 있다.
                
                ex) 만약 신뢰할만한 CA가 ‘샘의 서명 가게’를 위한 인증서에 서명을 하고, 샘의 서명 가게는 어떤 사이트 인증서에 서명을 한다면 → 브라우저는 그 인증서를 올바를 CA 경로에서 파생된 것으로 보고, 받아들일 수 있다.
                
    -   서명 검사
        
        한번 서명 기관이 믿을 만하다고 판단하면 → 브라우저는 서명 기관의 공개 키를 서명에 적용해서 → 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.
        
    -   사이트 신원 검사
        
        중간자 공격자가 트래픽을 가로채는 것을 방지하기 위해, 대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.
        
        서버 인증서에는 보통 단일 도메인 이름이 들어있지만, 몇몇 CA는 서버 이름 목록 등이 들어있는 인증서를 만든다.
        
        만약 호스트 명이 인증서의 신원과 맞지 않으면 → 사용자를 우선으로 생각하는 클라이언트는 반드시 이 사실을 사용자에게 알리거나 / 잘못된 인증서 에러와 함께 커넥션을 끊어야 한다.
        
###   14.7.7 가상 호스팅과 인증서

-   가상 호스팅 : 하나의 서버에서 여러 도메인/사이트를 운영하는 방식
-   가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것 / 인증서 관리는 다소 까다로울 수 있다.
-   몇몇 인기 있는 웹 서버 프로그램은 하나의 인증서만을 지원한다.
-   만약 사용자가 인증서의 이름과 일치하지 않는 가상 호스트명으로 접속하면 인증서 에러 대화 상자 / 경고 상자가 나타날 것이다.
    -   ex) [Example.com](http://Example.com) 사이트의 호스팅 제공자는 공식 이름 example.securesites.com을 제공한다.
        
        사용자가 [https://www.example.com으로](https://www.example.xn--com-ky7m580d) 접속했을때, 서버 인증서에 나열된 공식 호스트 이름(*.securesites.com)은 사용자가 브라우징했던 가상 호스트명([www.example.com](http://www.example.com))이랑 일치하지 않으므로 → 경고 상자가 나타난다.
        
        이러한 문제를 피하기 위해 → Example.com의 소유자는 보안 트랜잭션을 시작하는 모든 사용자를 example.securesites.com으로 리다이렉트한다.
        
##   14.8 진짜 https 클라이언트

-   ssl은 복잡한 바이너리 프로토콜이다.
    
-   ssl 클라와 서버 프로그래밍을 쉽게 만들어주는 몇 가지 상용 또는 오픈 소스 라이브러리들이 존재한다.
    
###   14.8.1 OpenSSL

-   인증서 관련 문제를 분석하고 확인할 수 있는 **CLI 디버깅 도구**입니다.
-   브라우저에서 인증서 오류 발생 시, 백엔드 서버의 인증서를 직접 확인해볼 수 있음
-   가장 인기 있는 ssl과 tls의 오픈 소스 구현체이다
-   강력한 다목적 암호법 라이브러리이다
-   Openssl은 SSLeay 라이브러리를 계승하였고, 인터페이스가 매우 비슷하다.

##   14.9 프락시를 통한 보안 트래픽 터널링

### **CONNECT 메서드로 만들어지는 HTTPS 터널**

-   HTTPS는 **평문이 아닌 암호화된 트래픽**이므로, 중간 프록시 서버에서 내용을 열람할 수 없습니다.
    
-   그래서 프록시는 브라우저가 보낸 `CONNECT example.com:443 HTTP/1.1` 요청을 통해
    
    **목적지 서버와 브라우저 간의 “터널”을 생성**해주기만 합니다.
    
    CONNECT 메서드 : 프록시 서버에게 HTTPS 통신을 위한 터널 생성 요청
    
-   이후 TLS 핸드셰이크는 브라우저 ↔️ 목적지 서버 간에 직접 수행됩니다.
    

### **회사/학교 네트워크에서 SSL 인터셉션 발생 가능**

-   일부 기업이나 학교는 **프록시 서버에서 SSL 트래픽을 복호화**해서 검사함 (보안 목적)
    
-   이 경우 브라우저는 실제 목적지 서버가 아닌 **중간 서버의 인증서**를 받게 됨 →
    
    인증서 경고 또는 실패 발생
