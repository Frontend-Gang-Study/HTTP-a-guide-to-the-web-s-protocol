#   11장 클라이언트 식별과 쿠키

-   웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다. 서버는 익명의 클라이언트로부터 받는 모든 요청을 처리 + 서버와 통신하고 있는 클라이언트를 추적해야할 수도 있다.

-   이 장에선 http 서버가 통신하는 대상 / 사용자를 식별해서 콘텐츠를 개인화시키는 데 사용하는 기술에 대해 알아볼거다.

##   11.1 개별 접촉

-   http는 익명으로 사용하며, 상태가 없고, 요청과 응답으로 통신한다.
    
-   웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.
    
-   현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어한다. 네트워크로 연결된 사용자들에 대해 더 많은 것을 알고 싶어 하고, 사용자들이 브라우징하는 것을 기록하고 싶어 한다.
    
    [amazon.com](http://amazon.com) 같이 유명한 온라인 쇼핑 사이트는 여러가지 방식으로 사이트를 개인화 시켜서 사용자에게 제공한다.
    
    -   개별 인사
        -   온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다
    -   사용자 맞춤 추천
        -   온라인 상점은 고객의 흥미가 무엇인지 학습해서 → 고객이 좋아할 것이라고 예상되는 제품들을 추천할 수 있다. 고객의 생일이나 다른 중요한 날이 다가오면 특별한 제품을 제시하기도 한다.
    -   저장된 사용자 정보 사용
        -   온라인 쇼핑 고객은 복잡한 주소와 신용카드 정보를 매번 입력하는 것을 싫어한다. 이런 정보를 데이터베이스에 저장하는 온라인상점도 있다. 온라인 쇼핑몰이 당신을 한번 식별하고 나면, 쇼핑을 더 편하게 할 수 있게 저장된 사용자 정보를 사용할 수 있다.
    -   세션 추적
        -   http 트랜잭션은 상태가 없다. 각 요청 및 응답은 독립적으로 일어난다. 많은 웹사이트에서 사용자가 사이트와 상호작용할 수 있게 사용자의 상태를 남긴다. ex) 장바구니. 이렇게 상태를 유지하려면, 웹 사이트는 각 사용자에게서 오는 http 트랜잭션을 식별할 방법이 필요하다.
        
##   11.2 http 헤더

-   사용자 관련 식별 관련 정보를 전달한다
    
-   사용자에 대한 정보를 전달하는 가장 일반적인 http 요청 헤더
    | 헤더 이름 | 헤더 타입 | 설명 |
	|-----------|-----------|------|
	| From | 요청 | 사용자의 이메일 주소 |
	| User-Agent | 요청 | 사용자의 브라우저 |
	| Referer | 요청 | 사용자가 현재 링크를 타고 온 페이지 |
	| Authorization | 요청 | 사용자 이름과 비번 |
	| Client-ip | 확장(요청) | 클라이언트의 ip 주소 |
	| X-Forwarded-For | 확장(요청) | 클라이언트의 ip 주소 |
	| Cookie | 확장(요청) | 서버가 생성한 id 라벨 |
  
    
    -   From
        
        -   사용자의 이메일 주소를 포함한다.
        -   각 사용자가 서로 다른 이메일 주소를 가지므로 → 이 헤더로 사용자를 식별할 수 있다
        -   단점 : 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 → 이 헤더를 보내는 브라우저는 많지 않다.
        -   로봇이나 스파이더는 데이터를 수집하는 과정에서 본의 아니게 웹 사이트에 문제를 일으켰을 때 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 이 헤더에 이메일 주소를 작성한다.
    -   User-Agent
        
        -   사용자가 쓰고 있는 브라우저의 이름과 정보, 어떤 경우엔 운영체제에 대한 정보를 포함
            
        -   특정 브라우저에서 제대로 동작하도록 콘텐츠를 죄적화하는 데 유용할 수 있지만, 특정 사용자를 식별하는 데는 큰 도움이 되지 않는다
            
        -   ex) 구글 크롬
            
            ```bash
            user-agent:
            Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36
            ```
            
    -   Referer
        
        -   사용자를 현재 페이지로 유입하게 한 웹페이지의 url을 가리킨다
            
        -   이 헤더 자체만으로 사용자를 식별할 수는 없지만, 사용자가 이전에 어떤 페이지를 방문했었는지 알려준다.
            
            이 헤더를 통해서 사용자의 웹 사용 행태나 사용자의 취향을 더 잘 파악할 수 있다.
            
            ex) 야구 사이트에서 현재 웹 서버로 접근한 것이라면, 서버는 접속한 사용자가 야구 애호가라고 유추할 수 있다.
            
##   11.3 클라이언트 ip 주소

-   클라이언트 ip 주소 추적으로 알아낸 ip 주소로 사용자를 식별
    
-   초기 웹 선구자들은 사용자 식별에 클라이언트 ip 주소를 사용하려 했다. 이 방식은 사용자가 확실한 ip 주소를 가지고 있고, 그 주소가 좀처럼 바뀌지 않고, 웹 서버가 요청마다 클라이언트의 ip를 알 수 있다면 문제 없이 동작한다.
    
-   클라이언트의 ip 주소는 보통 http 헤더에 없지만, 웹 서버는 http 요청을 보내는 반대쪽 tcp 커넥션의 ip 주소를 알아낼 수 있다.
    
    ex) 유닉스 시스템에서 getpeername 함수를 호출하면 요청을 보낸 클라이언트의 ip 주소를 받을 수 있다.
    
-   클라이언트 ip 주소로 사용자를 식별하는 방식의 문제점
    
    -   클라이언트 ip 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킨다. 만약 여러 사용자가 같은 컴퓨터를 사용한다면 → 그들을 식별할 수 없을 것이다.
        
    -   많은 인터넷 서비스 제공자 ISP는 사용자가 로그인하면 동적으로 ip 주소를 할당한다. 로그인한 시간이 따라 사용자는 매번 다른 주소를 받으므로 → 웹 서버는 사용자를 ip 주소로 식별할 수 없다.
        
    -   보안을 강화하려고 많은 사용자가 네트워크 주소 변환 network address translation NAT 방화벽을 통해 인터넷을 사용한다. 이 NAT 장비들은 클라이언트의 실제 ip 주소를 방화벽 뒤로 숨기고, 클라이언트의 실제 ip 주소를 내부에서 사용하는 하나의 방화벽 ip 주소로 변환한다.
        
        보안을 강화하려고 사용자가 네트워크 주소 변환 NAT 방화벽을 사용할 수 있는데, 이 NAT 장비들은 여러 클라이언트들의 ip 주소를 하나의 공용 ip 주소로 변환한다. 그러면 서버에선 여러 사용자를 동일한 ip로 인식해서 → 개별 사용자 식별 불가능
        
    -   보통 http 프락시와 게이트웨이는 원 서버에 새로운 tcp 연결을 한다. 웹 서버는 클라이언트의 ip 주소 대신 프락시의 ip 주소를 본다. 일부 프락시는 원본 ip 주소를 보존하려고 client-ip나 x-forwarded-for 같은 확장 헤더를 추가해서 이 문제를 해결하려고 한다. 하지만 모든 프락시가 이런식으로 동작하지는 않는다.
        
-   어떤 사이트는 보안 기능으로 ip 주소를 사용해서 → 특정 ip 주소로부터 오는 사용자에게만 문서를 전달하기도 한다. 이 방식은 인트라넷 같이 제한된 영역에선 적절할 수 있지만, 인터넷에선 ip 주소를 임의로 변경할 수 있기 때문에 문제가 발생할 수 있다.
    
##   11.4 사용자 로그인

-   웹 서버는 사용자 로그인 인증(사용자 이름과 비번으로 인증)할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
    
-   웹 사이트 로그인이 더 쉽도록 http는 authorization, www-authenticate 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
    
-   한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 → 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.
    
-   ex) 서버에서 사용자가 사이트에 접근하지 전에 로그인을 시키는 웹 애플리케이션
    
    1.  브라우저는 [www.joes-hardware.com](http://www.joes-hardware.com) 사이트로 요청을 보낸다
        
    2.  사이트는 사용자의 식별 정보를 알지 못하므로 서버는 401 login required와 www-authenticate 헤더를 반환하여 로그인하라고 요청한다. 이는 브라우저에 로그인 ui를 띄우게 한다.
        
    3.  사용자가 사용자 이름과 비번을 입력하고, 브라우저는 기존 요청을 다시 보낸다.
        
    4.  이제 서버는 사용자의 식별 정보를 안다.
        
    5.  이 시점 이후의 요청에 대해서 브라우저는 서버로부터 사용자 식별 정보를 요청 받거나 받지 않았을때 자동으로 사용자 이름과 비번을 포함해서 전달한다.
        
        사이트에 한 번만 로그인하면 브라우저는 요청마다 해당 사용자의 식별 정보 토큰을 authorization 헤더에 담아 서버로 전송해서, 한 세션이 진행되는 내내 그 사용자에 대한 식별을 유지한다.
        
##   11.5 뚱뚱한 url

-   사용자의 상태 정보를 포함하고 있는 url
    
-   url에 식별자를 포함하는 기술이다
    
-   어떤 웹 사이트는 사용자의 url마다 버전을 작성해서 사용자를 식별하고 추적했다.
    
    -   사용자가 사이트를 돌아다니면, 웹 서버는 url에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.
-   보통 Url은 url 경로의 처음이나 끝에 상태 정보를 추가해서 확장한다
    
-   ex) [amazon.com](http://amazon.com) 뚱뚱한 url
    
    -   웹 상점을 돌아다니는 사용자에게 할당된 식별 번호(여기선 002-1145265-8016838)를 각 url 뒤에 붙여서 사용자를 추적한다.
-   웹 서버와 통신하는 독립적인 http 트랜잭션을 하나의 세션 / 방문으로 묶는 용도로 뚱뚱한 url을 사용할 수 있다. 사용자가 웹 사이트에 처음 방문하면 유일한 id가 생성되고, 그 값은 서버가 인식할 수 있는 방식으로 url에 추가되며, 서버는 클라이언트를 이 뚱뚱한 url로 리다이렉트 시킨다. 서버가 뚱뚱한 url을 포함한 요청을 받으면 → 사용자 아이디와 관련된 추가적인 정보(장바구니, 프로필 등)을 찾아서 모든 하이퍼링크를 뚱뚱한 url로 바꾼다.
    
-   뚱뚱한 url은 사용자를 식별하는 데 사용할 수 있지만, 여러 심각한 문제가 있다.
    
    -   못생긴 url
        
        -   브라우저에 보이는 뚱뚱한 url은 새로운 사용자들에게 혼란을 준다
        
        _개발자 말고 보통 사용자는 url 잘 보지 않지 않음?_
        
    -   공유하지 못하는 url
        
        뚱뚱한 url은 특정 사용자와 세션에 대한 상태 정보를 포함한다. 만약 그 주소를 누군가에게 공유하면, 당신의 누적된 개인 정보를 본의 아니게 공유하게 된다.
        
    -   캐시를 사용할 수 없음
        
        -   url이 달라지기 때문에 기존 캐시에 접근할 수 없다
    -   서버 부하 가중
        
        -   서버는 뚱뚱한 url에 해당하는 html 페이지를 다시 그려야 한다.
    -   이탈
        
    -   세션 간 지속성의 부재
        
        -   사용자가 특정 뚱뚱한 url을 북마킹하지 않으면 로그아웃 하고 나서는 모든 정보를 잃는다.

##   11.6 쿠키

-   식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술
    
-   쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용됨
    
-   쿠키만으로 하기 힘든 일에는 위 기술들(11.3~11.5)을 함께 사용하기도 한다.
    
-   넷스케이프가 최초로 개발했지만 지금은 모든 브라우저에서 지원함
    
-   매우 중요한 웹 기술
    
-   새로운 http 헤더를 정의한다
    
-   쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않음.
    
###   11.6.1 쿠키의 타입

크게

-   **세션 쿠키 session cookie**
    -   임시 쿠키
    -   사용자가 사이트를 탐색할 때, 선호 사항 등을 저장
    -   사용자가 브라우저를 닫으면 삭제됨
-   **지속 쿠키 persistent cookie**
    -   디스크에 저장됨
    -   브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다
    -   세션 쿠키보다 더 길게 유지될 수 있음.
    -   사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용

로 나눌 수 있음

둘의 차이점은 **파기되는 시점** 뿐. Discard 파라미터가 설정돼있거나 / Expires 또는 Max-Age 파라미터가 없으면 세션쿠키가 된다.

###   11.6.2 쿠키는 어떻게 동작하는가

사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다.

처음에 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해서 아무것도 모른다. 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.

쿠키는 임의의 `이름=값` 형태의 리스트를 가지고, 그 리스트는 Set-Cookie / Set-Cookie2(확장 헤더) 같은 http 응답 헤더에 작성돼 사용자에게 전달한다.

-   쿠키는 어떤 정보든 포함할 수 있음
    -   서버가 사용자 추적 용도로 생성한 유일한 식별 번호만 포함하기도 한다.
        
        ex) 서버는 `id=34294` 라는 쿠키를 사용자에게 할당한다. 서버는 이 쿠키 값으로 데이터베이스에서 사용자의 정보(구매 내용, 주소 정보 등)를 찾는데 사용할 수 있다.

브라우저는 서버로부터 온 Set-Cookie / Set-Cookie2 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장한다.

사용자가 미래에 같은 사이트를 방문하면, 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 작성해 전송한다.

###   11.6.3 쿠키 상자: 클라이언트 측 상태

브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 클라이언트 측 상태(쿠키 명세에서의 공식적인 이름은 http 상태 관리 체계 http state management mechanism) 라고 한다.

각 브라우저는 다른 방식으로 쿠키를 저장한다.

-   구글 크롬 쿠키
    
    Cookies라는 파일에 쿠키를 저장한다.
    
    이 파일에 있는 각 행이 쿠키 한 개에 해당한다.
    
    -   name : 쿠키의 이름
    -   value : 쿠키의 값
    -   path : 쿠키 사용 접근이 가능한 페이지 경로
        -   **해당 경로의 하위 경로까지 모두 포함**한다.
        -   루트 경로 `/` : 모든 경로에서 쿠키가 유효
        -   `path=/home` 지정
            -   `/home/level1` → 접근 가능
            -   `/home/level1/level2` → 접근 가능
            -   `/hello` → 접근불가능 (다른 경로)
        -   기본값 : 루트 경로
            -   path를 입력하지 않으면 루트 경로로 자동 입력 된다.
        -   단, 쿠키의 범위를 좁게 잡을 수록 보안에는 좋다.
        -   동작 과정
            1.  사용자가 특정 URL에 접근할 때, 브라우저가 저장된 쿠키들을 검사합니다.
            2.  브라우저는 각 쿠키의 `path` 속성과 현재 요청하는 URL 경로를 비교합니다.
            3.  Path 조건이 맞으면, 브라우저가 해당 쿠키를 `Cookie` 헤더에 포함해서 서버로 전송합니다.
    -   secure : 해당 쿠키를 SSL 커넥션일 경우에만 보낼지 여부
    -   HttpOnly : 쿠키를 자바스크립트에서 액세스 하지 못하도록 제한. 해커가 자바스크립트로 쿠키를 탈취할수 없어, XSS 공격을 방지할 수 있다.

###   11.6.4 사이트마다 각기 다른 쿠키들

브라우저는

-   수천 개의 쿠키를 가지고 있을 수 있지만, 그렇다고 브라우저가 모든 쿠키를 모든 사이트에 보내지는 않는다.
    
-   보통 각 사이트에 2~3개의 쿠키만 보낸다.
    
-   이유
    
    -   브라우저가 쿠키를 모두 전달하면, 실제 콘텐츠의 바이트보다 더 많은 쿠키 바이트를 전달하는것이기에 성능이 크게 저하된다.
    -   쿠키들 대부분은 특정 서버에 특화된 이름/값 쌍을 포함하기에, 대부분 사이트에서는 인식하지 못하는 무의미한 값이다.
    -   모든 사이트에 쿠키 전체를 전달하는 것은, 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서 개인정보 문제를 일으킬 수 있다.
-   보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.
    
    ex) test.com에서 생성된 쿠키는 test.com에만 보내고, test2.com엔 보내지 않는다.
    
-   많은 웹 사이트는 광고를 관리하는 협력업체와 계약을 한다. 이 광고들은 웹 사이트의 일부인 것처럼 제작되고, **지속 쿠키**를 만들어낸다. 같은 광고사와 연결돼있는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버로 전송한다. 지속 쿠키의 도메인이 같기 때문이다. 광고사는 Referer 헤더를 접목해서 사용자의 프로필과 웹 사이트를 사용하는 습관에 대한 방대한 데이터를 구축할 수 있다.
    
-   최신 브라우저들은 개인정보 설정 기능을 통해 협력 업체의 쿠키 사용 방식에 제약을 걸 수 있도록 한다.
    

### 쿠키 Domain 속성

서버는 쿠키를 생성할 때 Set-cookie 응답 헤더에 domain 속성을 작성해서 **어떤 사이트가 그 쿠키를 읽을 수 있는지 제어**할 수 있다.

ex)

```jsx
Set-cookie: user="jeekim"; domain="test.com"
```

위 http 응답 헤더는 브라우저가 user=”jeekim”이라는 쿠키를 `.test.com` 도메인을 가지고 있는 모든 사이트에 / .test.com으로 끝나는 사이트에 전달한다는 의미다.

만약 사용자가 www.test.com이나 www.test.test.com 같이 `.test.com`으로 끝나는 사이트를 방문하면 아래 Cookie 헤더가 항상 적용될 것이다.

```jsx
Cookie: user="jeekim"
```

### 쿠키 Path 속성

웹 사이트 일부에만 쿠키를 적용할 수 있다. (url 경로의 앞부분을 가리키는) path 속성을 작성해서 해당 경로에 속하는 페이지에만 쿠키를 전달한다.

ex)

[www.test.com](http://www.test.com) 사이트는 자동차를 대여하는 페이지인 [http://www.test.com/autos에서](http://www.test.com/autos%EC%97%90%EC%84%9C) 사용자가 좋아하는 자동차 크기를 기록하려고 쿠키를 사용한다. 자동차 대여에 관한 쿠키는 아래와 같이 생성한다

```jsx
Set-cookie: pref="compact"; domain="test.com"; path="/autos"
```

만약 사용자가 [http://www.test.com/index.html에](http://www.test.com/index.html%EC%97%90) 접근하면 아래와 같은 쿠키만 얻게 된다

```jsx
Cookie: user="jeekim"
```

하지만 사용자가 [http://www.test.com/autos/index.html로](http://www.test.com/autos/index.html%EB%A1%9C) 접근하면 아래와 같은 두 가지 쿠키를 받게 될 것이다.

```jsx
Cookie: user="jeekim"
Cookie: pref="compact"
```

쿠키는 서버가 생성해서 클라이언트에 전달하고, 클라이언트는 그 쿠키를 유효한 사이트에만 전달하고 관리한다.

###   11.6.5 쿠키 구성 요소

현재 사용되는 쿠키 명세에는

-   version 0 쿠키와
-   version 1 쿠키

가 있다.

version 0 쿠키 명세는 http/1.1 명세 일부로 작성돼있지는 않다.

쿠키의 사용법에 대해 가장 잘 나와 있는 참고 자료 : `persistent client state: http cookies` (넷스케이프 쿠키 표준 원문)

###   11.6.6 version 0(넷스케이프) 쿠키

-   흔히 넷스케이프 쿠키라고 부른다.
    
-   최초의 쿠키 명세는 넷스케이프가 정의했다.
    
-   version 0 쿠키는 Set-cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필요한 필드들을 정의했다.
    
-   version 0 쿠키 형태
    
    ```jsx
    Set-cookie: name=value [; expires=date] [; domain=domain] [; path=path] [; secure]
    Cookie: name1=value1 [; name2=value2] ...
    ```
    
-   version 0 Set-cookie 헤더
    
    -   쿠키의 이름과 값을 가져야 한다.
    -   쿠키 옵션 속성들은 세미콜론으로 구분지어 작성한다.
    
	| 속성 | 필수/선택 | 설명 |
	|------|-----------|------|
	| 이름=값 | 필수 | 이름과 값 모두 큰따옴표로 감싸지 않은, 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열<br>`Set-cookie: user=jeekim` |
	| expires | 선택 | 날짜 문자열을 작성. 파기 일자에 다다르면, 그 쿠키는 삭제될 것이며 전달되지도 않을 것이다. 명시하지 않으면 해당 쿠키는 사용자의 세션이 끝날때 파기 된다.<br>날짜 형식 : `요일, DD-MM-YY HH:MM:SS GMT` 사용할 수 있는 타임존은 GMT 뿐. 날짜 요소 간의 구분은 대시`-`여야 함.<br>`Set-cookie: user=jeekim; expires=Mon, 06-Jan-25 09:56:17 GMT` |
	| domain | 선택 | 브라우저는 `Domain` 속성에 지정된 도메인 및 그 하위 도메인에 대해 쿠키를 전송한다.<br>기본값 : Set-cookie 응답을 생성한 서버의 호스트명<br>명시돼있지 않으면 Set-cookie 응답을 생성한 서버의 호스트명을 사용한다. test.com이면 'test.test.com'의 호스트명과는 짝이 맞지만, 'cnn.com'과는 맞지 않다.<br>`Set-cookie: user=jeekim; domain="test.com"` |
	| path | 선택 | 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다. path 속성에 작성된 값이 url 경로의 앞부분과 일치하면 쿠키를 전달한다.<br>`/` 경로는 도메인에 있는 모든 문서에 들어맞는다. '`/foo`' 경로는 '/foobar'과 '/foobar.html'에 들어맞는다.<br>기본값 : Set-cookie 응답을 전달하는 url의 경로<br>명시하지 않으면 Set-cookie 응답을 전달하는 url의 경로가 사용된다<br>`Set-cookie: user=jeekim; path="/autos"` |
	| secure | 선택 | 이 속성이 포함돼있으면 클라이언트가 서버에게 요청을 보낼 때 http가 SSL 보안 연결을 사용할 때만 / HTTPS 연결에서만 쿠키를 전송한다.<br>`Set-cookie: user=jeekim; secure` |
    
-   version 0 Cookie 헤더
    
    클라이언트가 요청을 보낼 때 현재 요청 URL에 맞고 Domain, Path, Secure과 같은 조건들에 맞고 아직 파기되지 않은 쿠키들만 자동으로 포함해서 보낸다.
    
    모든 쿠키는 Cookie 헤더에 이어 붙여 보낸다
    
    ```jsx
    Cookie: session-id=001; session-id-time=1000
    ```
    
###   11.6.7 version 1 (rfc 2965) 쿠키

-   version 1 쿠키는 version 0 쿠키의 확장 버전으로 널리 쓰이지는 않고, 현재는 사용되지 않는다.
-   set-cookie2와 cookie2 헤더를 소개
-   version 0 시스템과도 호환된다
-   넷스케이프 표준(원 버전)보다 좀 더 복잡하다
-   아직 모든 브라우저나 서버가 완전히 지원하지 않는다

###   11.6.8 쿠키와 세션 추적

-   쿠키는 웹 사이트에 수차례 트랜잭션을 만드는 사용자를 추적하는 데 사용한다.
    -   전자상거래 웹 사이트는 사용자가 온라인 쇼핑을 하는 중에도 그들의 장바구니를 유지하려 세션 쿠키를 사용한다.
        
    -   ex) Amazon.com에 방문하면 일어나는 연속 트랜잭션
        
        -   Amazon.com은 세션 쿠키를 이용해서 사용자를 추적한다
        -   (a) 브라우저가 amazon.com의 루트 페이지를 처음 요청한다.
        -   (b) 서버는 클라이언트를 전자상거래 소프트웨어 url로 리다이렉트 시킨다.
        -   (c) 클라이언트는 리다이렉트 url을 요청한다.
        -   (d) 서버는 응답에 2개의 세션 쿠키를 작성하고, 사용자를 다른 url로 이동시킨다.
        -   (e) 클라이언트는 새로운 url 요청을 앞서 받은 2개의 쿠키와 함께 보낸다.
        -   (f) 서버는 home.html 페이지로 리다이렉트 시키고, 쿠키 2개를 더 첨부한다.
        -   (g) 클라이언트는 home.html 페이지를 요청하고, 쿠키 4개를 요청에 포함한다.
        -   (h) 서버는 컨텐츠를 보낸다
###   11.6.9 쿠키와 캐싱

-   쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다. 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수 있다.
-   캐시를 다루는 기본 원칙
    -   캐시되지 말아야 할 문서가 있다면 표시하라
        -   문서를 캐시하면 될지 안 될지는 문서의 소유자가 가장 잘 안다.
            
        -   만약 문서가 Set-cookie 헤더를 제외하고 캐시를 해도 되는 경우 → 그 문서에 명시적으로 cache-control: no-cache=”set-cookie”를 작성한다
            
        -   캐시를 해도 되는 문서에 cache-control: public을 사용하면 웹의 대역폭을 더 절약시켜준다.
            
        -   ex) 공용 캐시에 개인화 응답이 저장된 경우
            
            1.  A 사용자가 로그인한 상태로 `/my-page`에 접속
                
                → 서버는 A의 정보를 포함한 응답을 생성
                
                → 서버가 실수로 이 응답에 `Cache-Control: public`을 설정하거나 아무 캐시 헤더도 설정하지 않음
                
                → 이 응답이 공용 캐시(CDN, 프록시)에 저장됨
                
            2.  B 사용자가 나중에 같은 URL(`/my-page`)에 접속
                
                → 캐시는 "이 경로는 캐싱된 게 있다!"고 생각하고, A의 응답을 그대로 전달
                
                → B는 A의 이름, 이메일, 주문 내역 등을 그대로 보게 됨
                
        -   캐시 금지 대상 민감 정보 목록
            
            -   프로필 페이지와 같이 사용자의 민감한 정보가 들어 있는 페이지
            
    -   set-cookie 헤더를 캐시하는 것에 유의해라
        -   같은 set-cookie 헤더를 여러 사용자에게 보내면, 사용자 추적에 실패할 것이기 때문이다.
            
        -   응답이 set-cookie 헤더를 가지면, 본문은 캐시할 수 있다.
            
        -   어떤 캐시는 응답을 저장하기 전에 set-cookie 헤더를 제거하기 때문에, 그 캐시 데이터를 받는 클라이언트는 set-cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다.
            
        -   캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 set-cookie 헤더 값을 작성해서 이 문제를 해결할 수 있다.
            
            -   원 서버는 아래와 같은 헤더를 캐시된 문서에 추가함으로써 재검사가 일어나게 할 수 있다.
                
                ```tsx
                cache-control: must-revalidate, max-age=0
                ```
                
        -   어떤 캐시는 set-cookie가 있는 이미지를 캐시 하지만, set-cookie가 있는 텍스트는 캐시 하지 않는다.
            
            
-   cookie 헤더를 포함한 요청은 액세스 토큰과 같이 개인 정보를 담고 있는 응답이 올 가능성이 높습니다. 따라서 이런 경우엔 캐시를 저장하지않게 백엔드에 Cache-Control: no-store로 설정하도록 요청할 수 있습니다.
-   프로필 페이지와 같이 사용자의 민감한 정보가 들어 있는 문서는 캐시되지 말아야 함. → Cache-Control: no-store로 캐시 저장을 하지 x

###   11.6.10 쿠키, 보안 그리고 개인정보

-   쿠키를 사용하지 않도록 비활성화 시키는 등의 처리를 할 수 있으므로 → 쿠키 자체가 보안상으로 엄청나게 위험한 것은 아니다.
    
-   원격 데이터베이스에 개인 정보를 저장하고, 해당 데이터의 키 값을 쿠키에 저장하는 방식을 사용하면, 클라이언트와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있다.
    
    _오 cabi datagrip으로 user table의 내 id랑 access token 쿠키에 있는 id랑 같아. 처음 알았어_
    
-   개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있기 때문에 → 항상 조심하는 것이 좋다.
    
    -   가장 큰 오용 중 하나 : 협력업체 웹 사이트가 사용자를 추적하려고 지속 쿠키를 사용하는 것.
        
        지속 쿠키를 ip 주소와 referer 헤더에 있는 정보와 함께 사용하면 → (마케팅) 회사들은 사용자의 프로필과 사용 패턴에 대해 꽤 정확한 데이터를 수집할 수 있다.
        
    -   제공하는 개인정보를 누가 받는지 명확히 알고, 사이트의 개인정보 정책에 유의한다면, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.

#   12장 기본 인증

-   사용자를 확인하는 기초적인 체계를 다룬다.

-   어떻게 http 인증이 데이터베이스와 동작하는지

-   웹사이트에 있는 개인의 프로필이나 개인이 작성한 문서는 해당 소유자의 동의 없이는 권한이 없는 사용자가 볼 수 없어야 한다. 또, 기업에 있는 민감한 전략 문서는 조직 내에서 권한이 없는 임직원이 볼 수 없게 해야 한다.

	이러기 위해선 서버가 사용자가 누구인지 식별할 수 있어야 한다. 서버가 사용자가 누구인지 알면, 그 사용자가 어떤 작업이나 리소스에 접근할 수 있는지 결정할 수 있다.

-   보통 사용자 이름과 비번을 입력해서 인증한다.

-   http는 자체적인 인증 관련 기능을 제공한다.

##   12.1 인증

-   http에 있는 2가지 공식적인 인증 프로토콜
    -   기본 인증
    -   다이제스트 인증

###   12.1.1 http의 인증요구/응답 프레임워크
-   http는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.
    
-   http 인증 모델
    
-   웹 애플리케이션이 http 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 (현재 사용자가 누구인지를 알 수 있게 비번과 같은 개인 정보를 요구하는) 인증 요구로 응답할 수 있다.
    
    -   사용자가 다시 요청을 보낼 땐, 인증 정보(사용자 이름, 비번)를 첨부해야 한다.
        -   인증 정보가
            -   맞지 않으면 → 서버는 클라이언트에 다시 인증 요구를 보내거나 에러를 낼 수 있다.
            -   맞으면 → 요청은 문제 없이 처리가 완료된다.

###   12.1.2 인증 프로토콜과 헤더
-   http는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해 → 다른 인증 프로토콜에 맞춰 확장할 수 있는 프레임워크를 제공한다.
    
-   인증 프로토콜은 http 인증 헤더에 작성돼 있다.
    
-   인증 단계

###   12.1.3 보안 영역
-   http가 어떻게 각 리소스마다 다른 접근 조건을 다루는지 보자
    
-   웹 서버는 기밀 문서를 보안 영역 realm 그룹으로 나눈다. 보안 영역은 저마다 다른 사용자 권한을 요구한다.
    
    ex) 웹 서버가 보안 영역을 회사의 재정 정보, 개인의 가족 문서 2개 가진다고 하자. 회사의 ceo는 판매 예측 자료에 접근할 수 있지만, 가족 방학 사진에 접근할 권한을 주지는 않을 것이다.
        
##   12.2 기본 인증

-   기본 인증은 잘 알려진 http 인증 규약이다.
    
-   거의 모든 주요 클라이언트와 서버에 기본 인증이 구현돼 있다.
    
-   기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비번을 요구할 수 있다. 서버는 200 대신 401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 www-authenticate에 작성해서 응답하여 → 인증 요구를 시작한다.
    
-   인증 정보를 포함하여 요청하라는 응답을 받은 브라우저는, 사용자에게 계정과 비번을 입력할 수 있는 UI를 연다.
    
    -   계정과 비번은 사용자가 해당 영역에 접근 권한이 있는지 검사하는 데 사용된다.
    -   브라우저는 사용자가 입력한 사용자 이름과 비번을 authorization 요청 헤더 안에 암호화해서 서버로 다시 보낸다.

    
###   12.2.2 base-64 사용자 이름/비번 인코딩

-   ex) 사용자 이름과 비번으로 기본 authorization 헤더 생성
    
-   base-64 인코딩
    
    -   바이너리, 텍스트, 국제 문자(ex. 유니코드)를 ASCII 문자(전송 가능한 문자인 알파벳, 숫자)으로 변환한다
    -   원본 문자열이 변질되지 않고 전송된다.
    -   국제 문자나 http 헤더에서 사용할 수 없는 문자(큰따옴표, 콜론, 캐리지 리턴)을 포함한 사용자 이름이나 비번을 보내야 할 때 유용할 수 있다.
    -   어렵지 않게 사용자 이름과 비번 문자를 섞을 수 있기 때문에 → 서버나 네트워크를 관리하면서 뜻하지 않게 사용자 이름과 비번이 노출되는 문제를 예방하는 데 도움이 된다.
-   보안에 대한 주의점
    
    -   Base64는 **암호화가 아님** → 단순히 인코딩일 뿐, 복호화가 너무 쉬움.
        
    -   ex) Authorization 헤더에서 `Basic YWRtaW46cGFzc3dvcmQ=`는 ID:PW를 그대로 노출한 것일 수 있음.
        
    -   cf) 인코딩 vs 암호화
        
        ## 인코딩
        
        **목적**: 데이터 형식 변환 및 호환성
        
        -   문자 집합 변환 (UTF-8, ASCII 등)
        -   전송 형식 맞춤 (Base64, URL 인코딩)
        -   데이터 표현 방식 변경
        
        인코딩이 데이터 형식을 변환하는 이유는 **서로 다른 시스템 간의 호환성과 안전한 전송**을 위해서입니다.
        
        ## 시스템 간 호환성 문제
        
        컴퓨터마다 문자를 표현하는 방식이 달랐습니다.
        
        ```
        영어: ASCII (7비트)
        한글: EUC-KR, CP949
        ```
        
		한글로 작성한 파일을 다른 나라 컴퓨터에서 열면 깨져 보이는 문제가 흔했습니다.
        
        ## 암호화
        
        **목적**: 데이터 보안 및 기밀성 보장
        
        -   권한 없는 접근 방지
        -   데이터 보호
###   12.2.3 프락시 인증

-   중개 프락시를 통해 인증할 수도 있다
    
-   어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시를 거치게 하여 사용자를 인증한다. 프락시에서 접근 정책을 중앙 관리할 수 있기 때문에 → 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해 프락시 서버를 사용하면 좋다.
    
    첫 번재 단계 : 프락시 인증으로 사용자를 식별하는 것
    
-   프락시 인증은 웹 서버의 인증과 헤더, 상태 코드만 다르고 절차는 같다.
    
-   웹 서버와 프락시 인증에서 쓰이는 상태 코드와 헤더들의 대조표
    
##   12.3 기본 인증의 보안 결함

-   기본 인증은 사용자 이름과 비번을 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다.
    
    인코딩한 비번은 누구나 읽기 쉽게 어렵지 않은 일반 문자열로 보낸다. base-64로 인코딩된 사용자 이름과 비번은 인코딩 절차를 반대로 수행해서 어렵지 않게 디코딩할 수 있다. base-64로 인코딩된 비번은 사실상 비번을 그대로 보내는 것과 다름 없다.
    
    누군가가 악의적으로 기본 인증으로 보낸 사용자 이름과 비번을 가로챌 수 있으므로 → 모든 http 트랜잭션을 ssl 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋다.
    
    -   프론트엔드 개발자가 HTTPS를 적용하거나 사용하는 방법
        
        ### 1. **HTTPS로 배포된 도메인에서만 서비스 실행**
        
        -   배포 환경에서는 프론트엔드 애플리케이션이 반드시 HTTPS로 접근되도록 설정해야 합니다.
        -   예: Netlify, Vercel, Cloudflare Pages, GitHub Pages 등 대부분의 정적 호스팅 서비스는 HTTPS를 자동 적용해줍니다.
        
        ----------
        
        ### 2. **백엔드 서버 또는 프록시 서버가 HTTPS를 제공하는지 확인**
        
        -   프론트엔드에서 호출하는 API 주소가 `http://`이면 **Mixed Content 오류** 발생 → 반드시 `https://`로 바꿔야 함.
        -   `axios` 또는 `fetch`로 API 호출할 때에도 HTTPS 사용 여부 확인:
        
	        ```
	        // 잘못된 예
	        fetch("<http://api.example.com/user>")
	        
	        // 올바른 예
	        fetch("<https://api.example.com/user>")
	        ```
        
        ----------
        
        ### 3. **서비스 워커(Service Worker) 또는 PWA 사용 시 HTTPS 필수**
        
        -   서비스 워커는 HTTPS 환경에서만 동작합니다. 따라서 PWA를 만들 경우 프론트 개발자가 HTTPS 배포 환경을 고려해야 합니다.
        
        ----------
        
        ### 4. **리디렉션 또는 강제 HTTPS 설정 요청**
        
        -   Cloudflare, Nginx, Netlify 등에서 HTTP 요청을 HTTPS로 자동 리디렉션하게 설정 가능
        -   프론트 개발자는 다음 설정을 인프라/백엔드 담당자에게 요청하거나 직접 설정할 수 있습니다:
        
	        ```
	        # HTTP를 HTTPS로 리디렉션
	        server {
	          listen 80;
	          server_name example.com;
	          return 301 https://$host$request_uri;
	        }
	        ```
        
        ----------
        
        ### 5. **HSTS (HTTP Strict Transport Security) 설정 요청**
        
        -   브라우저가 항상 HTTPS로만 접속하도록 유도하는 응답 헤더
        
	        ```
	        Strict-Transport-Security: max-age=63072000; includeSubDomains; preload
	        ```
        
        > 프론트 개발자는 이 헤더가 적용되었는지 확인하고, 필요 시 서버 설정을 요청할 수 있습니다.
        
-   기본 인증은 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다.
    
    보안 비번이 디코딩하기에 더 복잡한 방식으로 인코딩돼 있다고 하더라도, 여전히 누군가는 사용자 이름과 비번을 캡처한 다음, 그것을 그대로 원 서버에 보내서 인증에 성공하고, 서버에 접근할 수 있다.
    
-   비번을 요구하는 수많은 사이트에 지쳐버린 수많은 사용자는 그 모든 사이트에 같은 아이디와 비번을 사용한다.
    
    누군가는 무료 인터넷 이메일 같은 사이트에서 사용자 이름과 비번을 그대로 캡처하고, 동일한 사용자 이름과 비번으로 중요한 온라인 은행 사이트에 접근할 수도 있다.
    
-   메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않는다.
    
-   기본 인증은 가짜 서버의 위장에 취약하다.
    
    만약 사용자가 가짜 서버나 가짜 게이트에 연결돼 있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결돼 있다고 믿으면, 공격자는 사용자에게 비번을 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것이다.
    

----------

기본 인증은 사용자 이름과 비번을 base-64로 인코딩 합니다. base-64 인코딩은 인코딩 과정을 반대로 수행하면 디코딩할 수 있습니다. 때문에 기본 인증으로 전송한 사용자 이름과 비번을 공격자가 어렵지 않게 알아낼 수 있는 보안 문제가 있습니다. → 따라서 사용자 정보를 안전하게 전송하기 위해 HTTPS를 사용해 데이터를 암호화해야합니다.

----------

기본 인증

-   일반적인 환경에서 개인화나 접근을 제어하는데 편리
    
-   다른 사람들이 보지 않기를 원하기는 하지만, 보더라도 치명적이지 않은 경우에는 유용하다.
    
-   호기심 많은 사용자가 우연이나 사고로 정보에 접근해서 보는 것을 예방하는 데 사용한다.
    
-   ex) 회사는 한정판으로 우선 판매할 제품의 계획서와 같은 중요한 문서는 비번으로 보호할 수 있다. 기본 인증은 외부 업체가 해당 데이터에 접근하는 것을 상당히 불편하게 만든다.
    
    매 요청마다 인증 정보 필요
    
    -   기본 인증은 요청마다 `Authorization: Basic <base64 encoded id:password>` 헤더를 반드시 포함해야 해요.
    -   인증 정보를 누락하면 무조건 401 Unauthorized가 반환되고, 접근 자체가 막힘.
    
    ➡️ 자동화되지 않은 외부에서는 매우 번거롭게 느껴짐.
    
-   기본 인증은 사용자 이름과 비번을 공격자로부터 숨기려고 암호화된 데이터 전송(ex. SSL)과 연계해서 사용할 수 있다. - 널리 사용하는 기술임
