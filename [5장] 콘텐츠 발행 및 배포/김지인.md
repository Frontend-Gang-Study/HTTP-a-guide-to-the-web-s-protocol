#   18장 웹 호스팅
-   웹 호스팅
    
    -   : 콘텐츠의 리소스를 저장, 중개, 관리하는 일
    -   웹 서버의 가장 중요한 기능 중 하나

-   필요한 하드웨어와 소프트웨어를 직접 관리하기 어려우면 → 호스팅 서비스나 호스팅 업체가 필요할 것이다.
    
    호스팅 업체는 서버와 웹 사이트 프로그램을 대여해주고, 다양한 등급의 보안, 리포트, 사용 편의를 제공한다.
    
    보통 호스팅 업체는 공용 웹 서버에 올린다.


##   18.1 호스팅 서비스

-   월드 와이드 웹 초기엔 회사가 자체 컴퓨터 하드웨어를 구매하고, 자체 컴퓨터 망을 구축하며, 자체 네트워크 연결을 확보하고, 자체 웹 서버 소프트웨어를 관리했다.
    
    웹이 대세가 되면서, 많은 사람들이 웹 사이트를 원했지만, 냉난방 장치가 있는 서버실을 짓고, 도메인 이름을 등록하고, 네트워크 대역폭을 구매할 기술과 시간을 가진 사람은 드물었다.
    
    시간을 절약하기 위해, 전문적으로 웹 호스팅 서비스를 제공하는 여러 사업이 만들어졌다. 물리적인 장비 관리(공간, 냉난방, 연결)부터 ~ 고객이 직접 콘텐츠를 제공할 수 있는 웹 호스팅까지 다양한 종류의 서비스들이 있다.
        
##   18.2 가상 호스팅

-   많은 웹 호스팅 업자는 컴퓨터 한 대를 여러 고객이 공유하게 해서 저렴한 웹 호스팅 서비스를 제공한다 / 가상 호스팅을 한다.
    
    각 웹 사이트는 다른 서버에서 호스팅하는 것처럼 보이겠지만, 사실은 물리적으로 같은 서버에서 호스팅되는 것이다.
    
-   가상 호스팅은 비용, 공간, 관리에 이점이 있으므로 → 가상 호스팅을 제공하는 업체는 한 서버에 수십, 수백, 수천 개의 웹 사이트를 호스팅하려고 한다. 이는 pc 한대에 웹 사이트 1000개를 구축한다는 뜻은 아니다.
    
    호스팅 업체는 서버 팜(복제 서버 더미)을 만들고, 서버 팜에 부하를 분산할 수 있다. 팜에 있는 각 서버는 다른 서버를 복제한 것이며, 수많은 가상 웹 사이트를 호스팅하고 있기 때문에 → 관리자는 훨씬 편해진다.
    
###   가상 호스팅 동작하게 하기

초기 명세는 가상 호스팅을 고려하지 않았기 때문에, 웹 호스팅 업체는 공용 가상 호스팅을 지원하는 데 필요한 방법과 컨벤션을 개발해야 했다. 이 문제는 모든 http 요청 메시지에 (경로 컴포넌트만 보내는 것이 아니라) 완전한 url을 포함하여 간단히 해결했다.

http/1.1을 지원하는 서버는 http 요청 메시지에 있는 전체 url을 처리할 수 있어야 한다.

-   **ip 주소를 통한 가상 호스팅**
    
    -   각 가상 사이트에 별도의 가상 ip 주소를 한 개 이상 할당하고, 모든 ip 주소를 장비 하나에 / 같은 공용 서버에 연결한다.
        
    -   웹 서버는 ip 주소로 사이트를 식별한다. / http 커넥션의 목적지 ip 주소를 보고 클라가 어떤 웹 사이트에 연결하려고 하는지 알 수 있다.
        
    -   널리 쓰이는 방식임
      
    -   가상 호스팅은 규모가 아주 큰 호스팅 업체에게는 약간 어려운 문제를 안겨준다.
        
        -   일반적으로 컴퓨터 시스템이 연결할 수 있는 장비의 ip의 개수에는 제한이 있다. 호스팅 업체는 수백 수천 개의 가상 사이트를 포함하는 공용 서버를 제공해야해서 큰 문제다.
        -   ip 주소는 희소 상품이다. 가상 사이트를 많이 가지고 있는 호스팅 업체는 호스팅하는 모든 웹 사이트에 할당한 가상 ip 주소를 충분히 얻지 못할 수도 있다.
        -   ip 주소가 부족한 문제는 호스팅 업체가 용량을 늘리려고 서버를 복제하면서 더 심각해진다. 각 복제된 서버에 ip 주소를 부여해야 하므로 → ip 주소는 복제 서버의 개수만큼 더 필요하게 된다.
        
-   **host 헤더를 통한 가상 호스팅**
    
    -   가상 ip의 제한 문제를 피하려면 → 가상 사이트들이 같은 ip를 사용하더라도 각 사이트가 어디에 속해 있는지 알 수 있어야 한다.
        
        이 문제를 해결하려고 → 브라우저와 서버 개발자들은 서버가 원 호스트명을 받을 수 있게 http를 확장했다.
        
        하지만 대부분의 서버가 경로 컴포넌트만 받아 요청을 처리할 수 있기 때문에 → 브라우저가 전체 url을 보내더라도 소용없다. 대신, 모든 요청에 호스트명과 포트번호를 host 헤더에 작성해서 전달한다.
        
    -   http/1.0의 개선 버전과 http/1.1의 공식 버전은 사이트 이름을 알려주는 host 요청 헤더를 정의했다
        
    -   웹 서버는 host 헤더로 가상 사이트를 식별할 수 있다.
        
### http/1.1 host 헤더
    
-   확장 헤더임
    
-   http/1.1 명세를 따르려면 host 헤더를 반드시 작성해야 한다.
    
-   브라우저와 서버 대부분이 지원하지만, 아직 몇몇 클라, 서버, 로봇은 지원하지 않는다.
    
-   문법
    
    ```tsx
    Host: <host>:<port>
    ```
    
    -   요청 리소스에 대한 인터넷 호스트와 포트 번호를 작성한다
-   규칙
    
    -   host 헤더에 포트가 없으면 → 해당 스킴의 기본 포트를 사용한다
    -   url에 ip 주소가 있으면 → host 헤더는 같은 주소를 포함해야 한다.
    -   url에 호스트 명이 있으면 → host 헤더는 같은 호스트 명을 포함해야 한다
    -   url에 호스트 명이 있으면 → host 헤더는 url의 호스트 명이 가리키는 ip 주소를 포함하면 안 된다.(← 여러 개의 가상 사이트를 한 개의 ip 주소에 연결한 가상 호스트 서버에서 문제가 될 수 있기 때문)
    -   클라가 특정 프락시를 사용한다면 → host 헤더에 프락시가 아닌 원 서버의 호스트 명과 포트를 작성해야 한다. 안 그럼 프락시와 원 서버를 오동작시킬 수 있다.
    -   웹 클라는 모든 요청 메시지에 host 헤더를 작성해야 한다
    -   웹 프락시는 요청을 전달하기 전에 요청 메시지에 host 헤더를 추가해야 한다.
    -   http/1.1 웹 서버는 host 헤더 필드가 없는 http/1.1 메시지를 받으면 → 400 bad request를 응답해야 한다.
    
-   **host 헤더의 누락**
    
    -   몇몇 낡은 브라우저들은 host 헤더를 보내지 않는다.
    -   가상 호스팅 서버가 어떤 웹 사이트를 제공할지 결정하려고 host 헤더를 사용하려는 상황에서 host 헤더가 존재하지 않으면 → 서버는 사용자를 기본 웹페이지로 보내거나 / 브라우저를 업그레이드하라고 제안하는 에러 페이지를 반환할 수 있다.

-   **host 헤더 해석하기**
    
    웹 서버가 http/1.1을 통해 오는 리소스를 결정하기 위해 사용하는 규칙
    
    1.  http 요청 메시지에 절대 url이 있으면 → host 헤더에 있는 값은 무시하고 url을 사용한다
    2.  요청 메시지에 상대 url이 있고 && host 헤더가 있으면 → 호스트 명과 포트를 host 헤더에서 가져온다.
    3.  앞의 경우가 아니면 즉, 호스트를 결정할 수 없으면 → 클라이언트에게 400 bad request를 반환한다.

-   **host 헤더와 프락시**
    
    -   어떤 브라우저 버전은 부정확한 host 헤더를 보내는데, 특히 프락시를 사용하게 설정했을 때 그렇다.
        
        ex) 프락시를 사용하도록 구성할 때 버전이 오래된 애플 클라는 실수로 원 서버의 이름이 아닌 프락시의 이름을 host 헤더에 담아 전송한다.
        
##   18.3 안정적인 웹 사이트 만들기

-   웹 사이트에 장애가 생기는 상황들
    
    -   서버 다운
    -   트래픽 폭증
        -   갑자기 많은 사람들이 몰려드는 상황(특정 뉴스 방송을 보려고 하거나 할인 행사 때문에)
        -   갑작스러운 트래픽 폭증은 웹 서버에 과부하를 주어 느려지게 하거나 완전히 먼춰버리게 한다.
    -   네트워크 장애 / 손실

###   18.3.1 미러링 된 서버 팜

-   서버 팜의 서버에 있는 콘텐츠들은 한 곳에 문제가 생기면 다른 한 곳에서 대신 전달할 수 있게 미러링할 수 있다.
    
-   보통 미러링 된 서버는 계층적인 관계에 있다.
    
    -   마스터 원 서버 : 원본 콘텐츠를 가지고 있고, 콘텐츠의 원본 제작자같이 행동하는 서버
    -   복제 원 서버 : 마스터 원 서버로부터 콘텐츠를 받은 미러링 된 서버
    
    ----------
    
    -   미러링 된 서버 팜에서, 마스터 원 서버는 복제 원 서버에 콘텐츠를 보낼 책임이 있다.
        
        외부에서 볼 때, 이 콘텐츠를 가리키는 ip 주소는 스위치의 ip 주소다. 스위치는 서버에게 요청을 전송해야 하는 책임이 있다.
        
-   서버 팜에 배포하는 간단한 방법 : 네트워크 스위치를 사용해서 서버에 분산 요청을 보내는 것.
    
    -   서버에 호스팅 되고 있는 각 웹 사이트의 ip 주소는 스위치의 ip 주소가 된다.
-   미러링 된 웹 서버에는 다른 위치에 있는 콘텐츠와 정확히 같은 복제본이 있다.
    

###   18.3.2 콘텐츠 분산 네트워크 CDN

-   특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크다
-   네트워크 노드는 서버, 대리 서버, 프락시 서버가 될 수 있다.

###   18.3.3 CDN의 대리 캐시

-   대리 캐시
    -   리버스 프락시라고도 불린다
    -   특정 원 서버 집합을 대신해 미러링 된 웹 서버처럼 콘텐츠에 대한 / 원 서버를 가리키는 요청을 받는다.
    -   보통 원 서버와 대리 서버가 연결된다.
    -   대리 서버와 미러링 된 서버의 차이점
        -   대리 서버는 보통 수요에 따라서 동작한다는 것
        -   대리 서버는 원 서버의 전체 콘텐츠를 복사하지 않는다. 클라가 요청한 콘텐츠만 저장한다.
        -   원 서버는 대리 서버의 콘텐츠를 업데이트해 줄 의무는 없다
    -   많은 요청이 있는 콘텐츠를 빠르게 제공하려고, 사용자가 요청하기도 전에 콘텐츠를 가져오는 ‘미리 가져오기’ 기능을 가진 대리 서버도 있다.

###   18.3.4 CDN의 프락시 캐시

-   프락시 캐시
    -   대리 서버와는 다르게, 전통적인 프락시 캐시는 어떤 웹 서버 요청이든지 다 받을 수 있다.(프락시 캐시와 서버 간의 연동이 필요 없다)
    -   어떤 프락시는 요청을 많이 받는 콘텐츠를 미리 로딩하기도 한다
    -   요청이 있을 때만 저장한다
    -   스위치 혹은 라우터가 중간에서 웹 트래픽을 가로채 처리하기도 한다

##   18.4 웹 사이트 빠르게 만들기

-   서버 팜이나 분산 프락시 캐시나 대리 서버는 혼잡을 조절하고, 네트워크 트래픽을 분산시킨다.
    
    콘텐츠를 분산시키면 → 그 콘텐츠를 사용자에게 더 가깝게 만들어 주므로 → 콘텐츠를 서버에서 클라로의 전송하는 시간이 단축된다.
    
-   콘텐츠 인코딩
    
    ex) 클라가 받은 압축을 해제할 수 있다는 가정하에, 콘텐츠를 압축하는 것
