#   18장 웹 호스팅
-   웹 호스팅
    
    -   : 콘텐츠의 리소스를 저장, 중개, 관리하는 일
    -   웹 서버의 가장 중요한 기능 중 하나

-   필요한 하드웨어와 소프트웨어를 직접 관리하기 어려우면 → 호스팅 서비스나 호스팅 업체가 필요할 것이다.
    
    호스팅 업체는 서버와 웹 사이트 프로그램을 대여해주고, 다양한 등급의 보안, 리포트, 사용 편의를 제공한다.
    
    보통 호스팅 업체는 공용 웹 서버에 올린다.


##   18.1 호스팅 서비스

-   월드 와이드 웹 초기엔 회사가 자체 컴퓨터 하드웨어를 구매하고, 자체 컴퓨터 망을 구축하며, 자체 네트워크 연결을 확보하고, 자체 웹 서버 소프트웨어를 관리했다.
    
    웹이 대세가 되면서, 많은 사람들이 웹 사이트를 원했지만, 냉난방 장치가 있는 서버실을 짓고, 도메인 이름을 등록하고, 네트워크 대역폭을 구매할 기술과 시간을 가진 사람은 드물었다.
    
    시간을 절약하기 위해, 전문적으로 웹 호스팅 서비스를 제공하는 여러 사업이 만들어졌다. 물리적인 장비 관리(공간, 냉난방, 연결)부터 ~ 고객이 직접 콘텐츠를 제공할 수 있는 웹 호스팅까지 다양한 종류의 서비스들이 있다.
        
##   18.2 가상 호스팅

-   많은 웹 호스팅 업자는 컴퓨터 한 대를 여러 고객이 공유하게 해서 저렴한 웹 호스팅 서비스를 제공한다 / 가상 호스팅을 한다.
    
    각 웹 사이트는 다른 서버에서 호스팅하는 것처럼 보이겠지만, 사실은 물리적으로 같은 서버에서 호스팅되는 것이다.
    
-   가상 호스팅은 비용, 공간, 관리에 이점이 있으므로 → 가상 호스팅을 제공하는 업체는 한 서버에 수십, 수백, 수천 개의 웹 사이트를 호스팅하려고 한다. 이는 pc 한대에 웹 사이트 1000개를 구축한다는 뜻은 아니다.
    
    호스팅 업체는 서버 팜(복제 서버 더미)을 만들고, 서버 팜에 부하를 분산할 수 있다. 팜에 있는 각 서버는 다른 서버를 복제한 것이며, 수많은 가상 웹 사이트를 호스팅하고 있기 때문에 → 관리자는 훨씬 편해진다.
    
###   가상 호스팅 동작하게 하기

초기 명세는 가상 호스팅을 고려하지 않았기 때문에, 웹 호스팅 업체는 공용 가상 호스팅을 지원하는 데 필요한 방법과 컨벤션을 개발해야 했다. 이 문제는 모든 http 요청 메시지에 (경로 컴포넌트만 보내는 것이 아니라) 완전한 url을 포함하여 간단히 해결했다.

http/1.1을 지원하는 서버는 http 요청 메시지에 있는 전체 url을 처리할 수 있어야 한다.

-   **ip 주소를 통한 가상 호스팅**
    
    -   각 가상 사이트에 별도의 가상 ip 주소를 한 개 이상 할당하고, 모든 ip 주소를 장비 하나에 / 같은 공용 서버에 연결한다.
        
    -   웹 서버는 ip 주소로 사이트를 식별한다. / http 커넥션의 목적지 ip 주소를 보고 클라가 어떤 웹 사이트에 연결하려고 하는지 알 수 있다.
        
    -   널리 쓰이는 방식임
      
    -   가상 호스팅은 규모가 아주 큰 호스팅 업체에게는 약간 어려운 문제를 안겨준다.
        
        -   일반적으로 컴퓨터 시스템이 연결할 수 있는 장비의 ip의 개수에는 제한이 있다. 호스팅 업체는 수백 수천 개의 가상 사이트를 포함하는 공용 서버를 제공해야해서 큰 문제다.
        -   ip 주소는 희소 상품이다. 가상 사이트를 많이 가지고 있는 호스팅 업체는 호스팅하는 모든 웹 사이트에 할당한 가상 ip 주소를 충분히 얻지 못할 수도 있다.
        -   ip 주소가 부족한 문제는 호스팅 업체가 용량을 늘리려고 서버를 복제하면서 더 심각해진다. 각 복제된 서버에 ip 주소를 부여해야 하므로 → ip 주소는 복제 서버의 개수만큼 더 필요하게 된다.
        
-   **host 헤더를 통한 가상 호스팅**
    
    -   가상 ip의 제한 문제를 피하려면 → 가상 사이트들이 같은 ip를 사용하더라도 각 사이트가 어디에 속해 있는지 알 수 있어야 한다.
        
        이 문제를 해결하려고 → 브라우저와 서버 개발자들은 서버가 원 호스트명을 받을 수 있게 http를 확장했다.
        
        하지만 대부분의 서버가 경로 컴포넌트만 받아 요청을 처리할 수 있기 때문에 → 브라우저가 전체 url을 보내더라도 소용없다. 대신, 모든 요청에 호스트명과 포트번호를 host 헤더에 작성해서 전달한다.
        
    -   http/1.0의 개선 버전과 http/1.1의 공식 버전은 사이트 이름을 알려주는 host 요청 헤더를 정의했다
        
    -   웹 서버는 host 헤더로 가상 사이트를 식별할 수 있다.
        
### http/1.1 host 헤더
    
-   확장 헤더임
    
-   http/1.1 명세를 따르려면 host 헤더를 반드시 작성해야 한다.
    
-   브라우저와 서버 대부분이 지원하지만, 아직 몇몇 클라, 서버, 로봇은 지원하지 않는다.
    
-   문법
    
    ```tsx
    Host: <host>:<port>
    ```
    
    -   요청 리소스에 대한 인터넷 호스트와 포트 번호를 작성한다
-   규칙
    
    -   host 헤더에 포트가 없으면 → 해당 스킴의 기본 포트를 사용한다
    -   url에 ip 주소가 있으면 → host 헤더는 같은 주소를 포함해야 한다.
    -   url에 호스트 명이 있으면 → host 헤더는 같은 호스트 명을 포함해야 한다
    -   url에 호스트 명이 있으면 → host 헤더는 url의 호스트 명이 가리키는 ip 주소를 포함하면 안 된다.(← 여러 개의 가상 사이트를 한 개의 ip 주소에 연결한 가상 호스트 서버에서 문제가 될 수 있기 때문)
    -   클라가 특정 프락시를 사용한다면 → host 헤더에 프락시가 아닌 원 서버의 호스트 명과 포트를 작성해야 한다. 안 그럼 프락시와 원 서버를 오동작시킬 수 있다.
    -   웹 클라는 모든 요청 메시지에 host 헤더를 작성해야 한다
    -   웹 프락시는 요청을 전달하기 전에 요청 메시지에 host 헤더를 추가해야 한다.
    -   http/1.1 웹 서버는 host 헤더 필드가 없는 http/1.1 메시지를 받으면 → 400 bad request를 응답해야 한다.
    
-   **host 헤더의 누락**
    
    -   몇몇 낡은 브라우저들은 host 헤더를 보내지 않는다.
    -   가상 호스팅 서버가 어떤 웹 사이트를 제공할지 결정하려고 host 헤더를 사용하려는 상황에서 host 헤더가 존재하지 않으면 → 서버는 사용자를 기본 웹페이지로 보내거나 / 브라우저를 업그레이드하라고 제안하는 에러 페이지를 반환할 수 있다.

-   **host 헤더 해석하기**
    
    웹 서버가 http/1.1을 통해 오는 리소스를 결정하기 위해 사용하는 규칙
    
    1.  http 요청 메시지에 절대 url이 있으면 → host 헤더에 있는 값은 무시하고 url을 사용한다
    2.  요청 메시지에 상대 url이 있고 && host 헤더가 있으면 → 호스트 명과 포트를 host 헤더에서 가져온다.
    3.  앞의 경우가 아니면 즉, 호스트를 결정할 수 없으면 → 클라이언트에게 400 bad request를 반환한다.

-   **host 헤더와 프락시**
    
    -   어떤 브라우저 버전은 부정확한 host 헤더를 보내는데, 특히 프락시를 사용하게 설정했을 때 그렇다.
        
        ex) 프락시를 사용하도록 구성할 때 버전이 오래된 애플 클라는 실수로 원 서버의 이름이 아닌 프락시의 이름을 host 헤더에 담아 전송한다.
        
##   18.3 안정적인 웹 사이트 만들기

-   웹 사이트에 장애가 생기는 상황들
    
    -   서버 다운
    -   트래픽 폭증
        -   갑자기 많은 사람들이 몰려드는 상황(특정 뉴스 방송을 보려고 하거나 할인 행사 때문에)
        -   갑작스러운 트래픽 폭증은 웹 서버에 과부하를 주어 느려지게 하거나 완전히 먼춰버리게 한다.
    -   네트워크 장애 / 손실

###   18.3.1 미러링 된 서버 팜

-   서버 팜의 서버에 있는 콘텐츠들은 한 곳에 문제가 생기면 다른 한 곳에서 대신 전달할 수 있게 미러링할 수 있다.
    
-   보통 미러링 된 서버는 계층적인 관계에 있다.
    
    -   마스터 원 서버 : 원본 콘텐츠를 가지고 있고, 콘텐츠의 원본 제작자같이 행동하는 서버
    -   복제 원 서버 : 마스터 원 서버로부터 콘텐츠를 받은 미러링 된 서버
    
    ----------
    
    -   미러링 된 서버 팜에서, 마스터 원 서버는 복제 원 서버에 콘텐츠를 보낼 책임이 있다.
        
        외부에서 볼 때, 이 콘텐츠를 가리키는 ip 주소는 스위치의 ip 주소다. 스위치는 서버에게 요청을 전송해야 하는 책임이 있다.
        
-   서버 팜에 배포하는 간단한 방법 : 네트워크 스위치를 사용해서 서버에 분산 요청을 보내는 것.
    
    -   서버에 호스팅 되고 있는 각 웹 사이트의 ip 주소는 스위치의 ip 주소가 된다.
-   미러링 된 웹 서버에는 다른 위치에 있는 콘텐츠와 정확히 같은 복제본이 있다.
    

###   18.3.2 콘텐츠 분산 네트워크 CDN

-   특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크다
-   네트워크 노드는 서버, 대리 서버, 프락시 서버가 될 수 있다.

###   18.3.3 CDN의 대리 캐시

-   대리 캐시
    -   리버스 프락시라고도 불린다
    -   특정 원 서버 집합을 대신해 미러링 된 웹 서버처럼 콘텐츠에 대한 / 원 서버를 가리키는 요청을 받는다.
    -   보통 원 서버와 대리 서버가 연결된다.
    -   대리 서버와 미러링 된 서버의 차이점
        -   대리 서버는 보통 수요에 따라서 동작한다는 것
        -   대리 서버는 원 서버의 전체 콘텐츠를 복사하지 않는다. 클라가 요청한 콘텐츠만 저장한다.
        -   원 서버는 대리 서버의 콘텐츠를 업데이트해 줄 의무는 없다
    -   많은 요청이 있는 콘텐츠를 빠르게 제공하려고, 사용자가 요청하기도 전에 콘텐츠를 가져오는 ‘미리 가져오기’ 기능을 가진 대리 서버도 있다.

###   18.3.4 CDN의 프락시 캐시

-   프락시 캐시
    -   대리 서버와는 다르게, 전통적인 프락시 캐시는 어떤 웹 서버 요청이든지 다 받을 수 있다.(프락시 캐시와 서버 간의 연동이 필요 없다)
    -   어떤 프락시는 요청을 많이 받는 콘텐츠를 미리 로딩하기도 한다
    -   요청이 있을 때만 저장한다
    -   스위치 혹은 라우터가 중간에서 웹 트래픽을 가로채 처리하기도 한다

##   18.4 웹 사이트 빠르게 만들기

-   서버 팜이나 분산 프락시 캐시나 대리 서버는 혼잡을 조절하고, 네트워크 트래픽을 분산시킨다.
    
    콘텐츠를 분산시키면 → 그 콘텐츠를 사용자에게 더 가깝게 만들어 주므로 → 콘텐츠를 서버에서 클라로의 전송하는 시간이 단축된다.
    
-   콘텐츠 인코딩
    
    ex) 클라가 받은 압축을 해제할 수 있다는 가정하에, 콘텐츠를 압축하는 것

#   20장 리다이렉션과 부하 균형

-   리다이렉션 기술은 클라의 메시지를 명시적으로 요청하지 않은 곳으로 보낼 수 있다.
    
##  20.1 왜 리다이렉트인가?

-   http 애플리케이션이 항상 원하는 3가지
    -   신뢰할 수 있는 http 트랜잭션의 수행
    -   지연 최소화
    -   네트워크 대역폭 절약

위 때문에 웹 콘텐츠는 흔히 여러 장소에 배포된다. 이렇게 하면

-   한 곳에서 실패한 경우 → 다른 곳을 이용할 수 있으므로 → 신뢰성이 개선된다.
    
-   클라가 보다 가까운 리소스에 접근할 수 있게 되어 → 콘텐츠를 더 빨리 받게 되므로 → 응답 시간도 줄여준다
    
-   목적지 서버가 분산되므로 → 네트워크 혼잡도 줄어든다.
    
-   리다이렉션의 구현에는 부하 균형 구현이 포함된다. ← 둘은 서로 공존하기 때문
    
    대부분의 리다이렉션 장치들은 몇 가지 방식의 부하 균형을 포함한다. = 들어오는 메시지의 부하를 서버들의 집합에 분산할 수 있다.
    
    반대로, 어떤 방식의 부하 균형이든 리다이렉션을 포함한다.
    
##   20.2 리다이렉트 할 곳

-   서버, 프락시, 캐시, 게이트웨이는
    -   클라가 그들에게 http 요청을 보내고, 그들이 요청을 처리한다는 관점에서 보면, 클라에게 있어 모두 서버라고 할 수 있다.
    -   모두 공통적으로 서버의 특성을 갖고 있기 때문에 → 많은 리다이렉션 기법이 그들 모두에서 동작한다.
-   웹 서버는 ip 별로 요청을 다룬다. 똑같이 복제된 서버들로 요청을 분산한다는 것 = 같은 url에 대해 여러 곳에서 온 요청들을 각각 최적의 웹 서버로 보내겠다는 것
    -   클라에 가장 가까운 것이나
    -   부하가 가장 적은 것이나
    -   그 외의 이유로 최적인 것
-   프락시는 프로토콜별로 요청을 다룬다. 클라 근처에 프락시 캐시가 있다면, 모든 요청이 프락시 캐시로 흘러 들어가는 것이 이상적이다. ← 캐시는 자주 찾는 문서를 저장해서 클라에게 직접 제공하기 때문에 ⇒ 원 서버로의 더 오래 걸리고, 비용이 드는 통신을 피할 수 있기 때문

##   20.3 리다이렉션 프로토콜의 개요

-   리다이렉션의 목표 : http 메시지를 웹 서버로 가급적 빨리 보내는 것
-   http 메시지의 전송 방향
    -   브라우저 애플리케이션의 사용자는 브라우저가 클라 메시지를 프락시로 보내도록 설정할 수 있다
    -   dns 분석자는 메시지의 주소를 지정할 때 사용될 아이피 주소를 선택한다. 이 아이피 주소는 클라의 지리직 위치에 따라 달라질 수 있다.
    -   메시지는 여러 개의 (주소가 지정된) 패킷으로 나뉘어 네트워크를 통과한다. 스위치와 라우터는 패킷의 tcp/ip 주소를 검증하고, 패킷을 어떻게 라우팅할 것인지 결정한다.
    -   웹 서버는 http 리다이렉트를 이용해 → 요청이 다른 웹 서버로 가도록 할 수 있다.


##   20.4 일반적인 리다이렉션 방법

메시지를 서버로 리다이렉트하기 위해 사용되는 리다이렉션 방법

###   20.4.1 http 리다이렉션

-   웹 서버는 클라에게 다른 곳에 요청을 보내라고 말하는 짧은 리다이렉트 메시지를 줄 수 있다.
    
-   몇몇 웹 사이트는 http 리다이렉션을 이용해 → 간단하게 부하를 분산한다.
    
-   요청을 처리하는 리다이렉팅 서버는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트한다.
    
-   서버의 부하뿐 아니라 인터넷상에서의 브라우저와 서버 간의 거리도 계산에 넣어야 한다.
    
-   장점 : 리다이렉트를 하는 서버가 클라의 아이피 주소를 안다는 점. → 좀 더 정보에 근거해 선택할 수 있다.
    
-   동작 방법 : http 요청을 콘텐츠를 제공하기에 최적인 웹 서버를 선택해 줄 첫 번째 웹 서버로 간다. 이 웹 서버는 클라에게 선택한 서버로의 http 리다이렉션을 보낸다. 클라는 선택된 서버에게 다시 요청을 보낸다.
    
    1.  클라이언트가 서버에 요청을 보냅니다.
    2.  서버는 3xx 상태 코드와 `Location` 헤더에 리다이렉트 URL을 담아 응답합니다.
    3.  브라우저는 `Location` 헤더의 URL로 다시 요청을 보냅니다.
    
    -   ex)
        
        -   a - 클라이언트가 서버에 요청을 보냅니다.
            
            앨리스는 www.joes-hardware.com에 요청을 보낸다.
            
        -   b - 서버는 3xx 상태 코드와 `Location` 헤더에 새 URL을 담아 응답합니다.
            
            (http 200 상태코드와 함께 웹페이지의 본문을 전송하는 대신) 서버는 302와 함께 리다이렉트 메시지를 전송한다.
            
        -   c
            
            브라우저는 `Location` 헤더의 리다이렉트 url을 사용하여 호스트를 161.58.228.**45**로 하여 요청을 다시 보낸다. / 해당 URL로 다시 요청을 보냅니다.
            
            다른 클라는 다른 서버로 리다이렉트 될 수 있다.
            
        -   d~f
            
            밥의 요청은 161.58.228.**46**으로 리다이렉트됐다.
            
-   제약 사항 / 단점
    
    -   어떤 서버로 리다이렉트할 지 결정하려면, 원 서버는 상당히 많은 처리를 해야 한다. 때로는 거의 페이지 자체를 제공할 때 필요한 것과 거의 같은 양의 처리가 필요하다.
    -   느릴 수 있다. 리다이렉트가 발생하면 두 번 이상의 왕복이 필요하기 때문에, 사용자가 더 오래 기다리게 된다. 모든 트랜잭션이 추가 리다이렉트 단계를 포함한다.
    -   반드시 첫 번째 웹 서버가 요청 부하를 다룰 수 있어야 한다.
    -   리다이렉트 서버에 장애가 발생하면 → 최종 리소스에 도달하지 못해서 사이트에 치명적인 영향을 줄 수 있음.
-   위의 약점 때문에, http 리다이렉션은 보통 다른 리다이렉션 기법과 조합해서 사용된다.
    
###   20.4.2 dns 리다이렉션

-   클라이언트가 어떤 웹 사이트에 접근하려고 할 때마다, 도메인 이름 www.example.com은 반드시 아이피 주소로 분석돼야 한다.
    
-   dns 분석자는
    
    -   클라의 운영체제일 수도 있고
    -   클라의 네트워크에 있는 dns 서버이거나
    -   더 원격에 있는 dns 서버일 수도 있다
-   dns는 하나의 도메인에 여러 아이피 주소가 연관되는 것을 허용하고, dns 분석자는 여러 아이피 주소를 반환하도록 설정될 수 있다.
    
    분석자가 어떤 아이피 주소를 반환할 것인가를 결정하는 방법은 단순한 것(라운드 로빈) ~ 복잡한 것까지 다양하다.
    
-   ex)
    
    -   죠는 www.joes-hardware.com을 위해 서버 4개를 운용한다.
    -   dns 서버는 www.joes-hardware.com의 아이피 주소 4개 중 어떤 것을 돌려줄 지 결정해야 한다.
-   동작 방법 : dns 서버가 url의 호스트 명에 대한 응답으로 어떤 ip 주소를 사용할지 결정한다.
    
-   제약 사항 : dns 서버를 설정할 필요가 있다.
    
###   20.4.3 임의 캐스트 어드레싱

-   여러 지리적 위치의 서버가 **같은 IP 주소를 공유**하도록 설정
-   라우터는 **네트워크 거리** 기준으로 **가장 가까운 서버로 트래픽을 라우팅** / 라우터를 통해 네트워크상에서 **최단 경로에 있는 서버**를 자동으로 선택
-   클라이언트는 서버 위치를 모르고, 그냥 요청했는데 가장 가까운 엣지 서버에서 응답이 옴 → 성능 개선
-   **CDN 활용:** CDN이 애니캐스트를 활용하여 정적 파일(이미지, CSS, JS)을 사용자에게 빠르게 전송하여 웹사이트 로딩 속도를 최적화하는 데 기여
-   **CDN**, DNS 서비스 (예: Cloudflare, Google DNS)**에서 사용**
-   **대부분의 CDN**(ex. Cloudflare)**이 애니캐스트를 활용하여 사용자에게 가장 가까운 엣지 서버에서 콘텐츠를 제공합니다.**
-   임의 캐스트 어드레싱에서 지리적으로 흩어진 웹 서버들은 같은 아이피 주소를 갖고, 클라의 요청을 클라에서 가장 가까운 서버로 보내주기 위해 백본 라우터의 최단거리 라우팅 능력에 의지한다.
-   웹 서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본 라우터와 대화한다. 백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을때, 가장 가까운 라우터를 찾고 → 그 라우터에 패킷을 보낼 것이다.
-   서버는 라우터와 라우터 프로토콜을 사용해서 통신한다.
-   동작 방법 : **여러 서버가 같은 ip 주소를 사용한다.** **라우터들은 공유된 ip 주소로 향하는 패킷을 가장 가까운 서버에 보낸다.** / 여러 서버가 같은 IP 주소를 공유하지만, 라우팅 시스템이 가장 가까운 서버로 연결해줌
    -   ex)
        
        -   서버 3개가 같은 아이피 주소(10.10.10.1)를 향한다. 이 주소를
            
            -   LA 서버는 LA 라우터에게 광고했고,
            -   뉴욕 서버는 뉴욕 라우터에게 광고했고
            -   나머지도 이런식으로 했다
        -   라우터는 10.10.10.1을 향한 클라의 요청을 자동으로 이 주소를 광고한 가장 가까운 서버로 라우팅한다.
            
            여기서 10.10.10.1에 대한 요청은 서버 3으로 라우팅될 것이다.
            

-   제약 사항
    -   라우터를 설정해야 한다.
    -   주소가 충돌할 위험이 있다.
    -   라우팅이 바뀌고 && 커넥션과 연관된 패킷들이 다른 서버로 보내진다면 → 수립된 tcp 커넥션이 깨질 수도 있다.

###   20.4.4 아이피 맥 포워딩

-   네트워크 레벨에서 패킷을 **다른 주소로 전달**
-   IP 포워딩: 라우터가 패킷을 다른 네트워크로 전달
-   MAC 포워딩: 스위치나 브리지에서 **로컬 링크 상에서 주소 기반 전달**
-   프론트엔드에서는 보통 관여하지 않지만, **디버깅 시 네트워크 흐름 파악**에 도움

###   20.4.5 아이피 주소 포워딩

-   라우팅 테이블을 따라 다음 홉(next hop)으로 전달
-   VPN, 프록시 등에서 사용됨
-   예: 실제 IP가 아닌, 프록시 IP를 통해 우회접속

    
##   20.5 프락시 리다이렉션 방법

-   메시지를 프락시로 리다이렉트 하기 위해 사용되는 리다이렉션 방법
    
-   콘텐츠에 접근할 때 프락시를 통할 필요가 있는 경우도 있고(아마 보안상의 이유로), 클라가 이용하면 유익한 프락시 캐시가 네트워크에 있을 수 있다(아마 캐시된 콘텐츠를 받는 것이 원 서버로부터 받는 것보다 훨씬 빠를 것이기 때문).
    
-   프락시는 클라의 요청을 다른 프락시로 라다이렉트할 수 있다.
    
    ex) 요청 받은 콘텐츠를 가지지 않는 프락시 캐시는 클라를 다른 캐시로 리다이렉트하도록 할 것이다. = 클라가 리소스를 요청한 곳과는 다른 곳에서 응답이 오도록 하게 하는 것
    
###   20.5.1 명시적 브라우저 설정

-   브라우저 네트워크 설정에서 직접 프록시 주소를 입력하는 방식
    
-   클라이언트 단에서 프록시를 강제로 사용하거나 우회할 때 사용.
    
-   프론트엔드 디버깅 시 반드시 알아야 할 설정 항목.
    
-   대부분의 브라우저엔 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트 번호를 설정할 수 있는 메뉴가 있다. 사용자가 이를 설정하면 브라우저는 모든 요청에 대해 프락시와 접촉한다.
    
    몇몇 서비스 제공자들은 사용자들이 직접 브라우저의 설정을 변경하는 대신, 미리 설정이 다 되어 있는 브라우저를 다운받도록 한다. (이렇게 다운 받은 브라우저들은 접촉할 프락시의 주소를 알고 있다)
    
-   동작 방법 : 웹 브라우저는 가까운 프락시(보통 캐시임)에게 http 메시지를 보내도록 설정된다.
    
-   중요한 단점
    
    -   프락시들을 사용하도록 설정된 브라우저들은 프락시가 응답하지 않더라도 원 서버와 접촉하지 않는다. 만약 프락시가 다운됐거나 브라우저가 잘못 설정됐다면 → 사용자는 접속 문제를 경험할 것이다.
        
    -   네트워크 아키텍처를 변경했을 때 그 변경사항을 모든 최종 사용자에게 전파하는 것이 어렵다. 만약 서비스 제공자가 더 많은 프락시를 추가하길 원하거나 몇 개를 서비스에서 제거하길 원한다면 → 브라우저 사용자들은 그들의 프락시 설정을 변경해야만 한다.
        
        프락시 자동 설정은 이 문제를 해결한다.
        
###   20.5.2 프락시 자동 설정

-   pac proxy auto-configuration
    
-   올바른 프락시 서버에 접촉하기 위해 브라우저가 동적으로 자신을 설정할 수 있게 하는 자동 설정 방법이다.
    
-   넷스케이프 사가 정의함
    
-   거의 모든 브라우저가 지원한다
    
-   `.pac` 파일
    
    -   프록시 설정 파일
        
    -   브라우저에게 각 url에 대해 사용해야 할 프락시를 지정한다.
        
    -   FindProxyForURL 함수를 반드시 정의해야 한다.
        
        -   브라우저는 요청된 url마다 아래와 같이 이 함수를 호출한다. 그리고 함수가 반환한 값이 알려 주는 곳으로 접속한다.
            
            ```jsx
            return_val = FindProxyForURL(url_of_request, host_in_url);
            ```
            
        -   반환값
            
            -   문자열
            -   브라우저가 url을 요청해야 하는 위치 / 적절한 프락시의 주소를 반환
                -   접촉할 프락시들의 목록
                    -   ex) “PROXY [proxy1.domain.com](http://proxy1.domain.com); PROXY [proxy2.domain.com](http://proxy2.domain.com)”
                -   (브라우저가 어떤 프락시든 우회해서 원 서버로 바로 가야 함을 의미하는) “DIRECT”
    -   JavaScript로 작성됨
        
    -   ex)
        
        ```jsx
        function FindProxyForURL(url, host) {
          if (shExpMatch(host, "*.internal.com")) {
            return "DIRECT";
          }
          return "PROXY proxy.example.com:8080";
        }
        ```
        
-   ex)
    
    -   서버는 pac 파일을 자스 프로그램과 함께 돌려보낸다.
        
        이 자스 프로그램은 브라우저에게 요청한 url이
        
        -   “[netscape.com](http://netscape.com)” 도메인 안에 있다면 → 원 서버로 바로 접근하고
        -   아니면 → “[proxy1.joes-cache.com](http://proxy1.joes-cache.com)”으로 가라고 말해주는
        
        FindProxyForURL 함수는 갖는다.
        
-   클라이언트가 요청을 보낼 때 어떤 URL은 프록시를 타고, 어떤 URL은 직접 연결할지 결정.
    
-   자스 프로그램은 브라우저에게 dns 주소나 서브넷과 같은 호스트 명과 관련된 여러 매개변수에 근거해서 프락시를 선택하도록 요구할 수 있다.
    
-   프락시의 위치가 변경된 경우, 이를 반영하기 위해 pac 파일이 서버에서 업데이트되기 때문에 → pac은 브라우저가 자동으로 네트워크 아키텍처에서의 변경에 맞는 올바른 프락시에 접촉할 수 있도록 해줄 수 있다.
    
-   동작 방법 : 브라우저는 pac 파일을 얻기 위해 지정된 서버에 접촉하도록 설정돼야 한다. → 브라우저는 재시작할 때마다 설정 서버로부터 **pac 파일을 검색하고, 가져온다.**
    
-   제약 사항 : 브라우저는 반드시 설정된 서버로 질의를 보내도록 설정돼야 한다.
    
###   20.5.3 웹 프락시 자동발견 프로토콜

-   wpad web proxy autodiscovery protocol
    
-   PAC 파일을 자동으로 탐색해 사용하는 방식
    
-   브라우저가 `wpad.<domain>` 또는 (DHCP 옵션을 통해) `wpad.dat` 파일을 찾고, 이 파일을 통해 자동으로 프록시 설정
    
-   회사, 학교, 공공기관 환경에서 **브라우저가 자동으로 프록시를 타는 이유**를 이해할 때 중요
    
-   "내 코드는 정상인데 이상하게 요청이 안 감" → WPAD로 인한 자동 프록시 적용일 수 있음
    
-   목적 : 웹브라우저가 근처의 프락시를 찾아내어 → 사용할 수 있게 해주는 방법을 제공하는 것
    
-   **pac 파일 자동 발견**
    
    -   wpad 프로토콜은 pac 파일 url(설정 url curl으로 알려짐)을 발견한다. 이 pac 파일은 자스 프로그램을 실행한다.
-   wpad 프로토콜을 구현한 http 클라가 하는 일
    
    -   wpad를 이용해 pac 파일 curl을 찾는다
    -   url에 해당하는 pac 파일을 가져온다.
    -   프락시 서버를 알아내기 위해 이 pac 파일을 실행한다.
    -   pac 파일이 반환한 프락시에게 http 요청을 보낸다.

    
-   pac 파일 가져오기
    
    -   후보 curl이 생성되면, wpad 클라는 보통 그 curl로 get 요청을 만드는데, 이때 accept 헤더를 포함해야 한다.
        
    -   만약 curl 결과가 리다이렉트이면 → 그 리다이렉트가 향하는 곳이 클라의 최종 목적지이다.
        
-   언제 wpad를 실행하는가
    
    적어도 다음 중 하나의 상황에선 실행돼야 한다.
    
    -   웹 클라가 시작될때
    -   클라 호스트의 아이피 주소가 변경된 네트워킹 스택으로부터 어떤 언급이 있을 때마다
-   관리자를 위한 고려사항
    
    클라들이 호환을 위해 반드시 구현해야 하는 것은 dhcp와 dns a 레코드 검색 뿐이다. 관리자들도 그들의 환경이 이 둘 중 하나를 설정해야 한다.
    
-   동작 방법
    
    -   라우터는 패킷의 목적지 주소를 평가하고, 프락시나 미러링된 서버의 아이피 주소와 함께 리다이렉트 패킷을 캡슐화한다.
    -   기존의 많은 라우터들과 함게 일한다
    -   패킷은 캡슐화될 수 있지만, 클라의 아이피 주소는 잃지 않는다.
-   제약 사항
    
    -   반드시 wccp를 지원하는 브라우저를 사용해야 한다
    -   위상적인 topological 제약이 약간 있다.

##   20.6 캐시 리다이렉션 방법

###   20.6.1 **웹 캐시 조직 프로토콜 wccp web cache coordination protocol**

-   동작 방법 : 웹브라우저는 설정 서버에게 pac 파일에 대한 url을 물어본다. pac만 사용할 때와는 다르게 브라우저에 특정 설정 서버가 설정돼야 할 필요가 없다
-   웹 캐시 서버와 라우터 간 통신 프로토콜
-   CDN이나 프록시 캐시가 어떻게 작동하는지 이해하는 데 도움
-   프론트엔드에서 CDN 최적화 전략을 세울 때 배경 지식으로 유용
-   웹 라우터들이 웹 트래픽을 프락시 캐시로 리다이렉트 할 수 있도록 개발됨
-   라우터들과 캐시들 사이의 대화를 관리한다
-   라우터가 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 한다
-   wccp 리다이렉션 동작
    -   네트워크가 필요하다. 이 네트워크엔 라우터(wccp를 사용할 수 있는)와 캐시(다른 캐시와 의사소통할 수 있는)가 포함돼야 한다.
    -   라우터들의 집합과 그들의 대상이 되는 캐시들이 wccp 서비스 그룹을 구성한다. 이 서비스 그룹에서 어떤 트래픽이 어디로 어떻게 보내지는지, 서비스 그룹에서 부하가 캐시들 사이에서 어떻게 분산돼야 하는지 설정할 수 있다.
    -   라우터는 요청 패킷을 캐시로 보낸다
    -   서비스 그룹이 http 트래픽을 리다이렉션하도록 설정돼있다면 → 서비스 그룹의 라우터는 http 요청은 서비스 그룹의 캐시로 보낸다
    -   http 요청이 서비스 그룹의 라우터에 도착했을때, 라우터는 그 요청을 처리하기 위해 서비스 그룹의 캐시 중 하나를 선택한다.
    -   만약 캐시가 요청을 처리할 수 없다면 → 패킷은 라우터로 돌아간다.
    -   서비스 그룹의 구성원들은 지속적으로 다른 구성원들의 가용성을 확인하기 위해 하트비트 메시지를 교환한다.
-   wccp 메시지
    -   헤더 - 메시지 종류(here i am, i see you, assignment, removal query), wccp 버전을 포함한다
    -   구성 요소
###   20.6.**인터캐시 커뮤니케이션 프로토콜 icp**

-   캐시 서버 간 객체 위치 조회 프로토콜
-   캐시 히트/미스 개념 이해에 도움
###   20.6.**하이퍼텍스트 캐싱 프로토콜 htcp**

-   HTTP 캐시 간 통신에 사용
-   브라우저 캐싱과 서버 캐싱의 동작 원리 이해에 도움
-   Cache-Control 헤더 최적화할 때 참고가 됨

